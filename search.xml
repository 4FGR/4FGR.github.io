<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      
        <title>Codeforces等级分突破1200分纪念</title>
      
      <link href="/2025/12/06/%E7%94%9F%E6%B4%BB/codeforces-rating%E7%BA%AA%E5%BF%B5/"/>
      <url>/2025/12/06/%E7%94%9F%E6%B4%BB/codeforces-rating%E7%BA%AA%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1id="codeforces等级分突破1200分纪念">Codeforces等级分突破1200分纪念</h1><p>之前听闻CF 1200分是入门，本来以为很轻松就能达到，实际上一直在1100徘徊，在 cf round 1068div2.中，总算实现了这一目标，十分激动。看到名字从灰变绿，内心是不可能无动于衷的，我热爱这些传统算法，思考的过程让我着迷，但也未像Oier、acmer那样由于一定的压力持续努力。上次icpc-online落选，遗憾错过区域赛。现已经大三上，犹豫是否要参加ACM-ICPC，因为本来是要决定考研。但我想着，还是上吧。谁教我选了软件工程专业后，最爱算法呢？</p><p><img src="\images\codeforces\1200.png" alt="codeforces1200" /></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>C2Ladder之旅-1200</title>
      
      <link href="/2025/12/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/C2Ladder%E4%B9%8B%E6%97%85/C2Ladder-1200/"/>
      <url>/2025/12/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/C2Ladder%E4%B9%8B%E6%97%85/C2Ladder-1200/</url>
      
        <content type="html"><![CDATA[<p><a href="https://c2-ladders-juol.onrender.com/">C2Ladder</a></p><h1 id="c2ladder之旅-1200">C2Ladder之旅-1200</h1><h2 id="1">1</h2><details><summary><a href="https://codeforces.com/problemset/problem/1520/D">Same Differences</a></summary>You are given an array $a$ of $n$ integers. Count the number of pairs of indices $(i, j)$ such that $i < j$ and $a_j - a_i = j - i$.</details><p>注意到， <span class="math inline">\(a_j-a_i=j-i \Rightarrow a_j-j =a_i-i\)</span> ，用哈希记录值为 <spanclass="math inline">\(a_i-i\)</span> 的个数 <spanclass="math inline">\(n_i\)</span> ，假设共有 <spanclass="math inline">\(m\)</span> 组，则有： <spanclass="math display">\[ans = \sum\limits_{i=1}^m C_{n_i}^2\]</span></p><h2 id="2">2</h2><details><summary><a href="https://codeforces.com/problemset/problem/1537/C">Challenging Cliffs</a></summary><p>You are a game designer and want to make an obstacle course. Theplayer will walk from left to right. You have <spanclass="math inline">\(n\)</span> heights of mountains already selectedand want to arrange them so that the absolute difference of the heightsof the first and last mountains is as small as possible.</p><p>In addition, you want to make the game difficult, and since walkinguphill or flat is harder than walking downhill, the difficulty of thelevel will be the number of mountains <spanclass="math inline">\(i\)</span> (<span class="math inline">\(1 \leq i&lt; n\)</span>) such that <span class="math inline">\(h_i \leqh_{i+1}\)</span> where <span class="math inline">\(h_i\)</span> is theheight of the <span class="math inline">\(i\)</span>-th mountain. Youdon’t want to waste any of the mountains you modelled, so you have touse all of them.</p><p>From all the arrangements that minimize <spanclass="math inline">\(|h_1-h_n|\)</span>, find one that is the mostdifficult. If there are multiple orders that satisfy these requirements,you may find any.</p></details><p>显然，得先找到峰距最小的两座峰 <spanclass="math inline">\(l,r\)</span>（若有多组，它们的高度也应该是最小的），小的放第一位，大的放第二位。想要让difficulty 最大，就要尽量爬山，那么凡是高度大于峰 <spanclass="math inline">\(r\)</span> 先升序放，最后高度小于峰<spanclass="math inline">\(l\)</span>再升序放。显然，一开始就升序排序，能轻松解决上述两个子问题。</p><h2 id="3">3</h2><details><summary><a href="https://codeforces.com/contest/1541/problem/B">Pleasant Pairs</a></summary><p>You are given an array <span class="math inline">\(a_1, a_2, \dots,a_n\)</span> consisting of <span class="math inline">\(n\)</span><strong>distinct</strong> integers. Count the number of pairs of indices<span class="math inline">\((i, j)\)</span> such that <spanclass="math inline">\(i &lt; j\)</span> and <spanclass="math inline">\(a_i \cdot a_j = i + j\)</span>.</p></details><p>和 <span class="math inline">\(1\)</span><a href="https://codeforces.com/problemset/problem/1520/D">SameDifferences</a> 很像，但这道题是暴力，注意到对于 <spanclass="math inline">\(x\times y \leq 2n\)</span> ，对于正整数 <spanclass="math inline">\(x\)</span> ，可能的 <spanclass="math inline">\(y\)</span> 应该有多少种呢？应该为 <spanclass="math inline">\(\frac{2n}{x}\)</span>种，由于元素互不相同，对于一组元素，最坏情况有 <spanclass="math inline">\(\frac{2n}{1}+\frac{2n}{2}+\cdots+\frac{2n}{n}=2n*(1+\frac{1}{2}+\cdots+\frac{1}{n})\)</span>，由于调和级数 <span class="math inline">\(\sum \frac{1}{n}\)</span>可近似为 <span class="math inline">\(\ln n\)</span> ，因此这个暴力也就<span class="math inline">\(O(nlogn)\)</span> ，即每次直接找 <spanclass="math inline">\(1\cdots \lfloor\frac{2n}{x} \rfloor\)</span>的数是否存在并且下标 <span class="math inline">\(j&gt;i\)</span>且满足题干条件。也可以排完序（其中一维存原始下标）后在 <spanclass="math inline">\(a_i\times a_j\leq 2n\)</span> ，暴力搜满足 <spanclass="math inline">\(a_{i.v}\times a_{j.v} == a_{i.p}+a_{j.p}\)</span>的个数。</p><h2 id="4">4</h2><details><summary><a href="https://codeforces.com/problemset/problem/1527/B1"> Palindrome Game (easy version)</a></summary><p>A palindrome is a string that reads the same left to right and rightto left. For example, “101101” is a palindrome, while “0101” is not.</p><p>Alice and Bob are playing a game on a string <spanclass="math inline">\(s\)</span> <strong>(which is initially apalindrome in this version)</strong> of length <spanclass="math inline">\(n\)</span> consisting of the characters ‘0’ and‘1’. Both players take alternate turns with Alice going first.</p><p>In each turn, the player can perform one of the followingoperations:</p><ol type="1"><li>Choose any <span class="math inline">\(i\)</span> (<spanclass="math inline">\(1 \le i \le n\)</span>), where <spanclass="math inline">\(s[i] =\)</span> ‘0’ and change <spanclass="math inline">\(s[i]\)</span> to ‘1’. Pay 1 dollar.</li><li>Reverse the whole string, pay 0 dollars. This operation is onlyallowed if the string is currently <strong>not</strong> a palindrome,and the last operation was not reverse. That is, if Alice reverses thestring, then Bob can’t reverse in the next move, and vice versa.</li></ol><p>Reversing a string means reordering its letters from the last to thefirst. For example, “01001” becomes “10010” after reversing.</p><p>The game ends when every character of string becomes ‘1’. The playerwho spends minimum dollars till this point wins the game and it is adraw if both spend equal dollars. If both players play optimally, outputwhether Alice wins, Bob wins, or if it is a draw.</p></details><p>没有平局存在。</p><p>Alice唯一的赢面，当且仅当在 <span class="math inline">\(0\)</span>的个数非 <span class="math inline">\(1\)</span> 的情况下，<spanclass="math inline">\(s\)</span> 的长度 <spanclass="math inline">\(|s|\)</span> 为奇数，且最中心位置上为 <spanclass="math inline">\(0\)</span> ，使得 Bob 不能之后进行反转操作。</p><p>否则，由于 <span class="math inline">\(s\)</span> 初始为回文串，Alice不得不执行操作 <span class="math inline">\(1\)</span>，随后 Bob只要在对应方放置，使得 <span class="math inline">\(s\)</span>仍为回文串，Alice 就不得不一直执行操作 <spanclass="math inline">\(1\)</span> ，而 Bob总能找到恰当的时机反转，比如当轮到 Bob 操作时，若 <spanclass="math inline">\(0\)</span> 的个数为 <spanclass="math inline">\(1\)</span> ，就反转。此时，轮到 Bob 操作时，<spanclass="math inline">\(0\)</span>的个数不可能为偶数，否则说明一开始有奇数个 <spanclass="math inline">\(0\)</span> 。由于对称性，<spanclass="math inline">\(0\)</span> 只能在中间，为上述情况。</p><h2 id="5">5</h2><details><summary><a href="https://codeforces.com/problemset/problem/1539/C">Stable Groups</a></summary><p>There are <span class="math inline">\(n\)</span> students numeratedfrom <span class="math inline">\(1\)</span> to <spanclass="math inline">\(n\)</span>. The level of the <spanclass="math inline">\(i\)</span>-th student is <spanclass="math inline">\(a_i\)</span>. You need to split the students intostable groups. A group of students is called stable, if in the sortedarray of their levels no two neighboring elements differ by more than<span class="math inline">\(x\)</span>.</p><p>For example, if <span class="math inline">\(x = 4\)</span>, then thegroup with levels <span class="math inline">\([1, 10, 8, 4, 4]\)</span>is stable (because <span class="math inline">\(4 - 1 \le x\)</span>,<span class="math inline">\(4 - 4 \le x\)</span>, <spanclass="math inline">\(8 - 4 \le x\)</span>, <spanclass="math inline">\(10 - 8 \le x\)</span>), while the group withlevels <span class="math inline">\([2, 10, 10, 7]\)</span> is not stable(<span class="math inline">\(7 - 2 = 5 &gt; x\)</span>).</p><p>Apart from the <span class="math inline">\(n\)</span> given students,teachers can invite at most <span class="math inline">\(k\)</span>additional students with <strong>arbitrary</strong> levels (at teachers’choice). Find the minimum number of stable groups teachers can form fromall students (including the newly invited).</p><p>For example, if there are two students with levels <spanclass="math inline">\(1\)</span> and <spanclass="math inline">\(5\)</span>; <span class="math inline">\(x =2\)</span>; and <span class="math inline">\(k \ge 1\)</span>, then youcan invite a new student with level <spanclass="math inline">\(3\)</span> and put all the students in one stablegroup.</p></details><p>显然，先排序，保证每对相邻元素的间距为原排列最小。若每个间距大于<span class="math inline">\(x\)</span> 就不得不为 ans 贡献 <spanclass="math inline">\(1\)</span> ，用 <spanclass="math inline">\(map\)</span> 记录若填充这个间距需要的最少人员数<span class="math inline">\(t\)</span> ，可证明 <spanclass="math inline">\(t\)</span> 为间距差 <spanclass="math inline">\(\lfloor \frac{d-1}{x} \rfloor\)</span>。最后因此遍历 <span class="math inline">\(map\)</span> ，在 <spanclass="math inline">\(k\)</span> 充足的情况下优先补足小间距，直至 <spanclass="math inline">\(k\)</span> 用尽或遍历结束。</p><blockquote><p>由于对于间距 <span class="math inline">\(d\)</span> ， 邀请 <spanclass="math inline">\(k\)</span> 个学生，能产生 <spanclass="math inline">\(k+1\)</span> 个间隔，每个间隔最大为 <spanclass="math inline">\(x\)</span> ，因此 <spanclass="math inline">\(d\leq (k+1)\times x\)</span> ,因此 <spanclass="math inline">\(k = \lceil \frac{d}{x} \rceil -1\)</span>，考虑精度问题，<span class="math inline">\(\lceil \frac{a}{b}\rceil\)</span> 等价于 <span class="math inline">\(\lfloor \frac{a + b -1}{b}\rfloor\)</span> ，用整数运算转换为 <span class="math inline">\(k =\lfloor \frac{d-1}{x} \rfloor\)</span></p></blockquote><h2 id="6">6</h2><details><summary><a href="https://codeforces.com/problemset/problem/1559/C">Mocha and Hiking</a></summary><p>The city where Mocha lives in is called Zhijiang. There are <spanclass="math inline">\(n+1\)</span> villages and <spanclass="math inline">\(2n-1\)</span> directed roads in this city.</p><p>There are two kinds of roads:</p><ul><li><span class="math inline">\(n-1\)</span> roads are from village<span class="math inline">\(i\)</span> to village <spanclass="math inline">\(i+1\)</span>, for all <spanclass="math inline">\(1\leq i \leq n-1\)</span>.</li><li><span class="math inline">\(n\)</span> roads can be described by asequence <span class="math inline">\(a_1,\ldots,a_n\)</span>. If <spanclass="math inline">\(a_i=0\)</span>, the <spanclass="math inline">\(i\)</span>-th of these roads goes from village<span class="math inline">\(i\)</span> to village <spanclass="math inline">\(n+1\)</span>, otherwise it goes from village <spanclass="math inline">\(n+1\)</span> to village <spanclass="math inline">\(i\)</span>, for all <spanclass="math inline">\(1\leq i\leq n\)</span>.</li></ul><p>Mocha plans to go hiking with Taki this weekend. To avoid the tripbeing boring, they plan to go through every village <strong>exactlyonce</strong>. They can start and finish at any villages. Can you helpthem to draw up a plan?</p></details><p>很简单，想要判断是否仅一次遍历完所有村庄，只用判断三个条件:</p><ul><li><span class="math inline">\(1\)</span> 号村庄能被 <spanclass="math inline">\(n+1\)</span> 号村庄到达 （存在路 <spanclass="math inline">\(a[0]=1\)</span> ）</li><li><span class="math inline">\(n\)</span> 号村庄能到达 <spanclass="math inline">\(n+1\)</span> 号村庄</li><li>存在相邻的村庄 <span class="math inline">\(i、i+1\)</span>，前者能到 <span class="math inline">\(n+1\)</span> ，而 <spanclass="math inline">\(n+1\)</span> 号村庄能到 <spanclass="math inline">\(i+1\)</span></li></ul><p>若条件成立，根据条件输出即可。否则，输出 <spanclass="math inline">\(-1\)</span> 。</p><h2 id="7">7</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>C2Ladder之旅——序章</title>
      
      <link href="/2025/12/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/C2Ladder%E4%B9%8B%E6%97%85/C2Ladder%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%BA%8F%E7%AB%A0/"/>
      <url>/2025/12/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/C2Ladder%E4%B9%8B%E6%97%85/C2Ladder%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E5%BA%8F%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="c2ladder之旅序章">C2Ladder之旅——序章</h1><p><a href="https://c2-ladders-juol.onrender.com/">C2Ladder</a>是一个提供专于 <a href="https://codeforces.com/">Codeforces</a>OJ平台的刷题题单网站，是对于 a2oj 的更新、重构。这里，我们将从 Rating1200 的题出发，开始我们的——<strong>C2Ladder 之旅</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> C2Ladder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>算法板子[updating]</title>
      
      <link href="/2025/11/20/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E6%9D%BF%E5%AD%90/"/>
      <url>/2025/11/20/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E6%9D%BF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="板子">板子</h1><h2 id="数据结构">数据结构</h2><h3 id="单调栈队列">单调栈/队列</h3><h3 id="并查集">并查集</h3><h3 id="st表">ST表</h3><h3 id="线段树">线段树</h3><h3 id="珂朵莉树">珂朵莉树</h3><h2 id="图论">图论</h2><h3 id="存储">存储</h3><p>链式前向星</p><p>vec型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nxt,head,to;</span><br><span class="line"><span class="comment">//初始化 head.resize(n+1,-1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    nxt.<span class="built_in">push_back</span>(head[u]);</span><br><span class="line">    head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">    to.<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> nxt[N],head[N],to[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    nst[++cnt] = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断二分图">判断二分图</h3><h2 id="数学">数学</h2><h3 id="高精度">高精度</h3><h3 id="快速幂">快速幂</h3><p>若无需模，请无视 <span class="math inline">\(p\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a %p;</span><br><span class="line">        a = a*a %p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数">分解质因数</h3><p>朴素做法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">breakdown</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            n/=i;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>) res.<span class="built_in">push_back</span>(n); <span class="comment">//经过操作后留下了一个素数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性筛">线性筛</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; isPrime;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seive</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isPrime.<span class="built_in">assign</span>(n<span class="number">+1</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:prime)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            isPrime[i*j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉函数">欧拉函数</h3><h3 id="模逆元">模逆元</h3><p>当模数是素数 <span class="math inline">\(p\)</span> 时</p><p>单个乘法逆元使用快速幂 <spanclass="math inline">\(qpow(a,p-2,p)\)</span> 即可 （ <spanclass="math inline">\(a^{p-1} \equiv1 \pmod p\)</span>）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      
        <title>动态规划-树形DP</title>
      
      <link href="/2025/11/20/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/updating/%E6%A0%91%E5%BD%A2DP/"/>
      <url>/2025/11/20/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/updating/%E6%A0%91%E5%BD%A2DP/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://oi-wiki.org/dp/tree/">树形 DP - OIWiki</a></p></blockquote><h1 id="树形dp">树形DP</h1><p>树形 DP，即在树上进行的DP。由于树固有的递归性质，一般通过递归DFS（或BFS） 进行</p><h2 id="基础">基础</h2><details open>    <summary><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会 - 洛谷</a></summary>    某大学有 $n$ 个职员，编号为 $1\ldots n$。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</details><p>不妨设 <span class="math inline">\(f(i,0/1)\)</span> 表示以 <spanclass="math inline">\(i\)</span> 为根的子树当其根节点的值<strong>取/不取</strong> 的最优解（ <spanclass="math inline">\(0\)</span> 表示 <spanclass="math inline">\(i\)</span> 不去舞会，反之要去）</p><p>对于每个状态，都存在两种决策（以下 <spanclass="math inline">\(x\)</span> 为 <spanclass="math inline">\(i\)</span> 的所有儿子）</p><ul><li>上司不参加舞会时，下属可以参加，也可以不参加，是否参加取决于所能产生的最大快乐值，因此有</li></ul><p><span class="math display">\[f(i,0) = \sum max(f(x,0),f(x,1))\]</span></p><ul><li>上司参加舞会时，下属只能不参加，但下属的下属则未必</li></ul><p><span class="math display">\[f(i,1) = a_i + \sum f(x,0)\]</span></p><p>这里，设上司结点是其所有下属结点的父结点，找到总上司结点为根节点，从根节点DFS 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">//记录快乐值</span></span><br><span class="line"><span class="type">int</span> v[N]; <span class="comment">//是否为子节点</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N]; <span class="comment">//存放图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">//递归求dp</span></span><br><span class="line">    dp[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[x][<span class="number">1</span>] = a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[x])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i); <span class="comment">//先得到dp[i][0/1]</span></span><br><span class="line">        dp[x][<span class="number">0</span>] += <span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>]);</span><br><span class="line">        dp[x][<span class="number">1</span>] += dp[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,k;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; k;</span><br><span class="line">        g[k].<span class="built_in">push_back</span>(l);</span><br><span class="line">        v[l] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">            root = i; <span class="comment">//找到根节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树上背包">树上背包</h2><details open>    <summary><a href="https://www.luogu.com.cn/problem/P2014">P2014 [CTSC1997] 选课</a></summary>    <p>有 $N$ 门功课，每门课有若干学分，分别记作 $s_1,s_2,\cdots,s_N$，每门课有一门或没有直接先修课（若课程 $a$ 是课程 $b$ 的先修课即只有学完了课程 $a$，才能学习课程 $b$）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？</p></details>每门课最多只有一门先修课的特点，与有根树中最多只有一个父亲节点的特点类似。<p>因此可以想到根据这一性质建树，从而所有课程组成了一个森林结构。为了方便起见，我们可以新增一门<strong>0学分的课程</strong> （设其编号为 <spanclass="math inline">\(0\)</span>），作为所有无先修课课程的先修课，这样我们就将森林变成了一棵以 <spanclass="math inline">\(0\)</span> 号课程为根的树。</p><p>我们设 <span class="math inline">\(f(u,k,j)\)</span> 比表示以 <spanclass="math inline">\(u\)</span> 号点为根的子树中，已经遍历了 <spanclass="math inline">\(u\)</span> 号点的前 <spanclass="math inline">\(k\)</span> 棵子树，选了 <spanclass="math inline">\(j\)</span> 门课程的最大学分。</p><p>转移的过程结合了树形 DP 和背包 DP 的特点，我们枚举 <spanclass="math inline">\(u\)</span> 点的每个子结点 <spanclass="math inline">\(v\)</span> ，同时枚举以 <spanclass="math inline">\(v\)</span>为根的子树选了几门课程，将子树的结果合并到 <spanclass="math inline">\(u\)</span> 上。</p><p>记 <span class="math inline">\(x\)</span> 的儿子个数为 <spanclass="math inline">\(s_x\)</span> ，以 <spanclass="math inline">\(x\)</span> 为根的子树大小为 <spanclass="math inline">\(siz_x\)</span> ，可以写出下面的状态转移方程：<span class="math display">\[f(u,i,j) = \max \limits_{v,k\leq j,k\leq siz_v} f(u,i-1,j-k)+f(v,s_v,k)\]</span>注意上面状态转移方程的几个限制条件，这些条件确保了一些无意义的状态不会被访问到。</p><p><span class="math inline">\(f\)</span>的第二维可以很轻松地用滚动数组的方式省略掉，注意这时需要倒序枚举 <spanclass="math inline">\(j\)</span> 的值。</p><p>该做法的时间复杂度为 <span class="math inline">\(O(nm)\)</span></p><h2 id="换根dp">换根DP</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>各题型题解[updating]</title>
      
      <link href="/2025/10/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%90%84%E9%A2%98%E5%9E%8B%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/10/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%90%84%E9%A2%98%E5%9E%8B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="各题型题解">各题型题解</h1><style>    p {  text-indent: 2em;}</style><h2 id="算法基础">算法基础</h2><h3 id="贪心">贪心</h3><h3 id="模拟">模拟</h3><h3 id="枚举">枚举</h3><h3 id="分治">分治</h3><h3 id="排序">排序</h3><h3 id="二分">二分</h3><blockquote><p><a href="https://www.luogu.com.cn/problem/P1182#ide">P1182 数列分段Section II - 洛谷</a></p><p>二分答案</p></blockquote><h3 id="构造">构造</h3><h3 id="倍增">倍增</h3><h3 id="前缀和差分">前缀和/差分</h3><blockquote><p><ahref="https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/description/?envType=daily-question&amp;envId=2025-10-30">1526.形成目标数组的子数组最少增加次数 - 力扣（LeetCode）</a></p></blockquote><details>    <summary>题目大意</summary>    问对初始全为0的序列，如果每次仅允许对[l,r]区间的所有元素加1，那么求出得到target数组的最少操作次数</details><p>我们知道对差分数组作前缀和能得到原数组。由于 <code>target</code>是通过 <span class="math inline">\([l,r]\)</span> 区间元素加 <spanclass="math inline">\(1\)</span> 得到的，<code>target</code> 的差分数组<code>diff</code> 显然记录了这样的过程：</p><ul><li>每次 <span class="math inline">\([l,r]\)</span> 操作对应 <spanclass="math inline">\(diff[l]+1\)</span> 、 <spanclass="math inline">\(diff[r+1]-1\)</span></li><li>在操作结束后，对 <code>diff</code> 作前缀和操作，得到<code>target</code></li></ul><p>我们要做的显然就是 “溯源”。</p><p>事实上，最少操作次数为其差分数组中正整数之和。</p><details>    <summary>证明</summary>    <p>显然正整数是操作的痕迹，想要做一次区间操作就不得不在 $diff[l]$ 加上 $1$ ，在 $diff[r+1]$ 处减去 $1$ ，显然差分数组每个正整数 $a$ 都代表有 $a$ 次操作从该位置开始。那么，负数，不会对这些产生影响吗？我们能保证绝不会有一次操作加在负数上，否则绝不会是最少操作解。因为要想加在负数上，只有对 $[l,r]$ 和 $[r+1,t]$ 分别做一次操作才能实现，显然只对 $[l,r]$ 做一次操作更为有效。    </p></details><h3 id="离散化">离散化</h3><h3 id="双指针">双指针</h3><h2 id="数据结构">数据结构</h2><h3 id="堆">堆</h3><h3 id="单调栈队列">单调栈/队列</h3><h3 id="st表">ST表</h3><h3 id="跳表">跳表</h3><h3 id="并查集">并查集</h3><h3 id="线段树">线段树</h3><h3 id="珂朵莉树">珂朵莉树</h3><blockquote><p><a href="https://www.luogu.com.cn/problem/P4979">P4979 矿洞：坍塌 -洛谷</a></p></blockquote><details>    <summary>题目大意</summary>    对于给出的一字符串s，仅存在三种三种元素：{A,B,C}，对于此字符串，我们想要做如下两种操作：    1. 当flag = A时，给出x,y,op,修改区间[x,y]的所有元素为op。    2. 当flag = B时，给出x,y,查询区间是否"合法"   一个区间合法的标志是：[x,y]区间的元素均相同，且第x-1号元素和第y+1号元素并不相同</details><p>这里给出珂朵莉树的解法，实现上采用 <code>std::set</code>，保留经典操作 <code>split</code> 和<code>assign</code>，此时如果直接暴力查询，则能得到90分，剩下10分考虑算法优化。</p><p>显然，珂朵莉树适用于数据集随机的情况，但此题显然B型操作过多。我们知道当存在大量不同区间时，珂朵莉树从理想下的<span class="math inline">\(O(mloglogn)\)</span>趋近于平方级。考虑题重要的一点：元素仅存在三种。说明大量不同区间实际上是可以合并的，比如<code>assign</code>操作后可能新区间能与邻居区间合并，于是选择在<code>assign</code> 采用<code>union</code> 操作。虽然时间仍差了一步，但 <code>union</code>带来的惊喜是，显然<strong>相同值的连续区间一定能被一个结点表示</strong>，那么就可以优化查询操作（这是最重要的），即得到大于<code>x</code> 的第一个结点的前驱 <code>itl</code>，大于 <code>y</code>的第一个结点的前驱 <code>itr</code> ，那么显然<code>itl</code> 和<code>itr</code> 是一定包含 <code>l</code> 和 <code>r</code>的。于是我们知道:</p><ul><li><code>itl</code>!=<code>itr</code> ，说明 <spanclass="math inline">\([l,r]\)</span> 区间值不全相同，返回 <spanclass="math inline">\(false\)</span></li><li><code>itl-l &lt; l &amp;&amp; itr&gt;r</code> 说明 <spanclass="math inline">\(x-1\)</span> 和 <spanclass="math inline">\(y+1\)</span> 的值相同，非法，返回 <spanclass="math inline">\(false\)</span></li><li>如果结点只包含 <span class="math inline">\([l,r]\)</span> 检查 <spanclass="math inline">\(prev(itl) == next(itr)\)</span>，如果成立，非法，返回 <span class="math inline">\(false\)</span></li><li>其余返回 <span class="math inline">\(true\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">char</span> v;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">const</span> <span class="type">int</span> &amp;il,<span class="type">const</span> <span class="type">int</span> &amp;ir,<span class="type">const</span> <span class="type">char</span> &amp;iv): <span class="built_in">l</span>(il),<span class="built_in">r</span>(ir),<span class="built_in">v</span>(iv)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;o) <span class="type">const</span>&#123;<span class="keyword">return</span> l&lt;o.l;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;node&gt; odt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(<span class="number">1</span>,N<span class="number">+1</span>,<span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = odt.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(x,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(it!=odt.<span class="built_in">end</span>()&amp;&amp;it-&gt;l==x) <span class="keyword">return</span> it;</span><br><span class="line">    it--;</span><br><span class="line">    <span class="type">int</span> l=it-&gt;l,r=it-&gt;r;<span class="type">char</span> v=it-&gt;v;</span><br><span class="line">    odt.<span class="built_in">erase</span>(it);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,x<span class="number">-1</span>,v));</span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(x,r,v)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">upper_bound</span>(<span class="built_in">node</span>(x,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(set&lt;node&gt;::iterator a)</span></span>&#123; <span class="comment">//查看是否能合并周围结点，如果能就合并</span></span><br><span class="line">    <span class="keyword">auto</span> l = a,r = <span class="built_in">next</span>(a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prev</span>(a)-&gt;v == a-&gt;v)&#123;</span><br><span class="line">        l = <span class="built_in">prev</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">next</span>(a)-&gt;v == a-&gt;v)&#123;</span><br><span class="line">        r = <span class="built_in">next</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">next</span>(l) != r)&#123;</span><br><span class="line">        <span class="type">int</span> il = l-&gt;l,ir = <span class="built_in">prev</span>(r)-&gt;r,iv = l-&gt;v;</span><br><span class="line">        odt.<span class="built_in">erase</span>(l,r);</span><br><span class="line">        odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(il,ir,iv));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">char</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = <span class="built_in">split</span>(r<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> itl = <span class="built_in">split</span>(l);</span><br><span class="line">    odt.<span class="built_in">erase</span>(itl,itr);</span><br><span class="line">    <span class="keyword">auto</span> it = odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,v)).first;</span><br><span class="line">    <span class="built_in">merge</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLegal</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = <span class="built_in">prev</span>(<span class="built_in">find</span>(r)),itl=<span class="built_in">prev</span>(<span class="built_in">find</span>(l)); <span class="comment">// 左端点&lt;=r 和&lt;=l的区间 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(itr != itl) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//[l,r]区间里不止一个区间（值）</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(itl-&gt;l &lt; l &amp;&amp; itr-&gt;r &gt; r) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//两边值一样</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(itl-&gt;l == l &amp;&amp; itr-&gt;r == r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">prev</span>(itl)-&gt;v == <span class="built_in">next</span>(itr)-&gt;v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">initial</span>(N);</span><br><span class="line">    <span class="type">char</span> a[N<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l = i;</span><br><span class="line">        <span class="keyword">while</span>(a[i] == a[i<span class="number">+1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assign</span>(l,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="type">char</span> flag;</span><br><span class="line">        cin &gt;&gt; flag;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="type">char</span> op;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; op;</span><br><span class="line">            <span class="built_in">assign</span>(x,y,op);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="built_in">isLegal</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="k-d树">K-D树</h3><h2 id="动态规划">动态规划</h2><h3 id="背包dp">背包DP</h3><h4 id="0-1完全混合背包">0-1/完全/混合背包</h4><h4 id="分组背包">分组背包</h4><h4 id="二维费用背包">二维费用背包</h4><h4 id="依赖背包">依赖背包</h4><h3 id="区间dp">区间DP</h3><h3 id="树型dp">树型DP</h3><h4 id="树上背包">树上背包</h4><h4 id="换根dp">换根DP</h4><h3 id="dag的dp">DAG的DP</h3><h3 id="状压dp">状压DP</h3><h3 id="数位dp">数位DP</h3><h3 id="插头dp">插头DP</h3><h3 id="计数dp">计数DP</h3><h2 id="图论">图论</h2><h3 id="dfs">DFS</h3><h3 id="bfs">BFS</h3><h3 id="拓扑排序">拓扑排序</h3><h3 id="最短路">最短路</h3><h3 id="最小生成树">最小生成树</h3><h3 id="二分图">二分图</h3><h3 id="哈密顿图">哈密顿图</h3><h3 id="网络流">网络流</h3><h3 id="最近公共祖先">最近公共祖先</h3><h3 id="树链剖分">树链剖分</h3><h2 id="多项式与生成函数">多项式与生成函数</h2><h3 id="快速傅里叶变换">快速傅里叶变换</h3><h3 id="快速数论变换">快速数论变换</h3><h2 id="数论">数论</h2><h3 id="素数筛法">素数/筛法</h3><h3 id="质因数分解">质因数分解</h3><h3 id="gcdlcm">gcd/lcm</h3><h3 id="欧拉函数">欧拉函数</h3><h3 id="费马小定理">费马小定理</h3><h3 id="模逆元">模逆元</h3><h3 id="线性同余方程">线性同余方程</h3><h3 id="中国剩余定理">中国剩余定理</h3><h3 id="数论分块">数论分块</h3><h3 id="pollard-rho-算法">Pollard Rho 算法</h3><h3 id="莫比乌斯反演">莫比乌斯反演</h3><h2 id="字符串">字符串</h2><h3 id="后缀函数">后缀函数</h3><h3></h3><h2 id="计算几何">计算几何</h2><h2 id="其他">其他</h2><h3 id="打表">打表</h3><blockquote><p><ahref="https://leetcode.cn/problems/next-greater-numerically-balanced-number/?envType=daily-question&amp;envId=2025-10-24">2048.下一个更大的数值平衡数 - 力扣（LeetCode）</a></p></blockquote><p>由于 <span class="math inline">\(n\leq 10^6\)</span>，数据较小，可直接枚举。为了实现更快的速度，我们枚举并同时记录每个平衡数，直到得到第一个大于<span class="math inline">\(10^6\)</span>的数值平衡数。然后二分打表即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nextBeautifulNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">122</span>,<span class="number">212</span>,<span class="number">221</span>,<span class="number">333</span>,<span class="number">1333</span>,<span class="number">3133</span>,<span class="number">3313</span>,<span class="number">3331</span>,<span class="number">4444</span>,<span class="number">14444</span>,<span class="number">22333</span>,<span class="number">23233</span>,<span class="number">23323</span>,<span class="number">23332</span>,<span class="number">32233</span>,<span class="number">32323</span>,<span class="number">32332</span>,<span class="number">33223</span>,<span class="number">33232</span>,<span class="number">33322</span>,<span class="number">41444</span>,<span class="number">44144</span>,<span class="number">44414</span>,<span class="number">44441</span>,<span class="number">55555</span>,<span class="number">122333</span>,<span class="number">123233</span>,<span class="number">123323</span>,<span class="number">123332</span>,<span class="number">132233</span>,<span class="number">132323</span>,<span class="number">132332</span>,<span class="number">133223</span>,<span class="number">133232</span>,<span class="number">133322</span>,<span class="number">155555</span>,<span class="number">212333</span>,<span class="number">213233</span>,<span class="number">213323</span>,<span class="number">213332</span>,<span class="number">221333</span>,<span class="number">223133</span>,<span class="number">223313</span>,<span class="number">223331</span>,<span class="number">224444</span>,<span class="number">231233</span>,<span class="number">231323</span>,<span class="number">231332</span>,<span class="number">232133</span>,<span class="number">232313</span>,<span class="number">232331</span>,<span class="number">233123</span>,<span class="number">233132</span>,<span class="number">233213</span>,<span class="number">233231</span>,<span class="number">233312</span>,<span class="number">233321</span>,<span class="number">242444</span>,<span class="number">244244</span>,<span class="number">244424</span>,<span class="number">244442</span>,<span class="number">312233</span>,<span class="number">312323</span>,<span class="number">312332</span>,<span class="number">313223</span>,<span class="number">313232</span>,<span class="number">313322</span>,<span class="number">321233</span>,<span class="number">321323</span>,<span class="number">321332</span>,<span class="number">322133</span>,<span class="number">322313</span>,<span class="number">322331</span>,<span class="number">323123</span>,<span class="number">323132</span>,<span class="number">323213</span>,<span class="number">323231</span>,<span class="number">323312</span>,<span class="number">323321</span>,<span class="number">331223</span>,<span class="number">331232</span>,<span class="number">331322</span>,<span class="number">332123</span>,<span class="number">332132</span>,<span class="number">332213</span>,<span class="number">332231</span>,<span class="number">332312</span>,<span class="number">332321</span>,<span class="number">333122</span>,<span class="number">333212</span>,<span class="number">333221</span>,<span class="number">422444</span>,<span class="number">424244</span>,<span class="number">424424</span>,<span class="number">424442</span>,<span class="number">442244</span>,<span class="number">442424</span>,<span class="number">442442</span>,<span class="number">444224</span>,<span class="number">444242</span>,<span class="number">444422</span>,<span class="number">515555</span>,<span class="number">551555</span>,<span class="number">555155</span>,<span class="number">555515</span>,<span class="number">555551</span>,<span class="number">666666</span>,<span class="number">1224444</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="染色">染色</h3><h3 id="中心扩散法">中心扩散法</h3>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      
        <title>算法基础-前缀和、差分、离散化</title>
      
      <link href="/2025/10/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/updating/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2025/10/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/updating/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和差分离散化">前缀和、差分、离散化</h1><blockquote><p>参考资料：</p><p><a href="https://oi-wiki.org/basic/prefix-sum/">前缀和 &amp; 差分 -OI Wiki</a></p><p><a href="https://oi-wiki.org/misc/discrete/">离散化 - OI Wiki</a></p></blockquote><h2 id="前缀和">前缀和</h2><p>数列前 <span class="math inline">\(n\)</span>项的和，是一种重要的预处理方式。</p><h3 id="一维前缀和">一维前缀和</h3><p>可得到其递推式<span class="math inline">\(S_0=0,S_i =S_{i-1}+a_i\)</span></p><p>作一维前缀和数组 <spanclass="math inline">\(ps\)</span>，其中下标i表示前 <spanclass="math inline">\(i\)</span> 项的和</p><p>对区间[l,r]求和，显然用 <spanclass="math inline">\(ps[r]-ps[l-1]\)</span> 即可，时间复杂度为 <spanclass="math inline">\(O(1)\)</span></p><h3 id="二维多维前缀和">二维/多维前缀和</h3><p>将一维前缀和扩展到多维的情形。其常见的求解方法有两种</p><h4 id="基于容斥原理">基于容斥原理</h4><p>多用于二维前缀和的情形。给定大小为 <spanclass="math inline">\(m\times n\)</span> 的二维数组 <spanclass="math inline">\(A\)</span> ，要求求出其前缀和 <spanclass="math inline">\(S\)</span>。那么，<spanclass="math inline">\(S\)</span> 同样是大小为 <spanclass="math inline">\(m\times n\)</span> 的二维数组，且</p><p><span class="math display">\[S_{i,j} = \sum\limits_{i&#39;\leq{i}}\sum\limits_{j&#39;\leq{j}}A_{i&#39;j&#39;}\]</span></p><p>显然，对于 <spanclass="math inline">\(S_{i,j}\)</span>，我们可以通过容斥原理获得:</p><p><span class="math display">\[S_{i,j} =A_{i,j}+S_{i-1,j}+S_{i,j-1}-S_{i-1.j-1}\]</span></p><p>形象的说，当前元素的值为上面的值和左边的值相加，减去左对角线的值后再加上原数组的对应下标的值。</p><p>当然，对于第一行和第一列，其值代表原数组第一行和第一列的前缀和</p><h4 id="逐维前缀和">逐维前缀和</h4><p>对于一般的情形，给定 <span class="math inline">\(k\)</span> 维数组<span class="math inline">\(A\)</span>，大小为 <spanclass="math inline">\(N\)</span>，同样要求得其前缀和 <spanclass="math inline">\(S\)</span>。</p><p><span class="math display">\[S_{i...i_k} =\sum\limits_{i&#39;_1\leq{i_1}}...\sum\limits_{i&#39;_k\leq{i_k}}A_{i&#39;...i&#39;_k}\]</span></p><p>从上式可以看出，<span class="math inline">\(k\)</span> 维前缀和就等于<span class="math inline">\(k\)</span>次求和。那么，每次只考虑一个维度，固定所有其它维度，然后求若干个一维前缀和，这样对所有<span class="math inline">\(k\)</span> 个维度分别求前缀和后，就得到<span class="math inline">\(k\)</span> 维前缀和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三维前缀和示例</span></span><br><span class="line"><span class="type">int</span> N1, N2, N3;</span><br><span class="line">std::vector&lt;std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&gt; a,</span><br><span class="line">    ps;  <span class="comment">// (N1 + 1) x (N2 + 1) x (N3 + 1).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate prefix sum of 3d array.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prefix_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ps = a;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prefix-sum for 3rd dimension.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N1; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N2; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= N3; ++k) ps[i][j][k] += ps[i][j][k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prefix-sum for 2nd dimension.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N1; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N2; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= N3; ++k) ps[i][j][k] += ps[i][j - <span class="number">1</span>][k];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prefix-sum for 1st dimension.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N1; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N2; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= N3; ++k) ps[i][j][k] += ps[i - <span class="number">1</span>][j][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为考虑每一个维度时，都只遍历了整个数组一遍，这样的时间复杂度是<span class="math inline">\(O(kN)\)</span>的</p><p>基于此，我们可以实现对一定范围的区域求区域和。例如，对二维原矩阵中，求左上顶点为<span class="math inline">\((i_1,j_1)\)</span> 、右下顶点 <spanclass="math inline">\((i_2,j_2)\)</span>的矩形区域和，可通过如下式子求解</p><p><spanclass="math display">\[S[i_2][j_2]-S[i_1-1][j_2]-S[i_2][j_1-1]+S_[i_1-1][j_1-1]\]</span></p><h4 id="特例子集和dp">特例：子集和DP</h4><p>维度比较大的情形，经常出现在一类叫做 <strong>子集和</strong>（sumover subsets,SOS）的问题中。这是高维前缀和的特例。</p><p>问题描述如下。考虑 大小为 <span class="math inline">\(n\)</span>的集合的全体子集上面定义的函数 <spanclass="math inline">\(f\)</span>，现在要求求出其子集和函数 <spanclass="math inline">\(g\)</span> ，它满足</p><p><spanclass="math display">\[g(s)=\sum\limits_{T\subseteq{S}}f(T)\]</span></p><p>即 <span class="math inline">\(g(s)\)</span> 等于其所有子集 <spanclass="math inline">\(T\sube S\)</span> 上的函数值 <spanclass="math inline">\(f(T)\)</span> 的和。</p><p>首先，子集和问题可以写成高维前缀和的形式。注意到，<spanclass="math inline">\(S\)</span> 的子集可以通过状态压缩的思想表示为<span class="math inline">\(n\)</span> 维数组，且每个维度下标都一定在<span class="math inline">\(\set{0,1}\)</span>中。同时，子集的包含关系就等价于下标的大小关系，即</p><p><span class="math display">\[T\sube{S}\Longleftrightarrow\forall{i}(t_i\leq s_i)\]</span></p><p>所以，对子集求和，就是求这个 <span class="math inline">\(n\)</span>维数组的前缀和。</p><p>显然，通过逐维前缀和的方法可求得子集和，时间复杂度为 <spanclass="math inline">\(O(n2^n)\)</span></p><p>子集和的逆操作需要通过容斥原理进行。子集和问题也是快速莫比乌斯变换的必要步骤之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考代码</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a,ps; <span class="comment">//length = 1&lt;&lt;n(2^n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum_of_subset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ps = a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//每次得到第i维的累加和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st=<span class="number">0</span>;st&lt;(<span class="number">1</span>&lt;&lt;n);st++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st &gt;&gt; i &amp; <span class="number">1</span>)&#123; <span class="comment">//二进制的st的第i位为1</span></span><br><span class="line">                <span class="comment">//ps[...1...] += ps[...0...] (i-th dimension)</span></span><br><span class="line">                ps[st] += ps[st^(<span class="number">1</span>&lt;&lt;i)]; <span class="comment">//按字符串维度进行n维前缀和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树上前缀和">树上前缀和</h3><p>一维前缀和还可以推广到有根树（树根为1）的情形。通过预处理前缀和，可以快速求解树上一段路径的权值和。</p><h4 id="点权的情形">点权的情形</h4><p>首先讨论权值存储在结点处的情形。设结点 <spanclass="math inline">\(x\)</span> 处有权值 <spanclass="math inline">\(a_x\)</span> 。可通过递推关系</p><p><span class="math display">\[S_1=a_1, S_x =S_{fa(x)}+a_x\]</span></p><p>求出从根结点到结点 <span class="math inline">\(x\)</span>的路径上的结点的权值和，其中， <spanclass="math inline">\(fa(x)\)</span> 表示 <spanclass="math inline">\(x\)</span>的父结点。预处理万前缀和后，就可以通过</p><p><spanclass="math display">\[S_x+S_y-S_{lca(x,y)}-S_{fa(lca(x,y)}\]</span></p><center>或</center><p><spanclass="math display">\[S_x+S_y-2*S_{fa(lca(x,y))}-a_{lca(x,y)}\]</span></p><p>计算连接结点 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的路径上的结点权值和。<spanclass="math inline">\(lca(x,y)\)</span> 表示结点 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 的<strong>最近公共祖先</strong>。</p><h4 id="边权的情形">边权的情形</h4><p>该情形几乎可以转化为点权的情形。对于所有非根结点，记 <spanclass="math inline">\(edge(x)\)</span> 为连接结点 <spanclass="math inline">\(x\)</span> 和其父结点 <spanclass="math inline">\(fa(x)\)</span> 的边，结点 <spanclass="math inline">\(x\)</span> 处存储的是边 <spanclass="math inline">\(edge(x)\)</span> 上的边权。根结点处存储的权值是<span class="math inline">\(0\)</span>。那么，显然递推关系和点权一致。</p><p><span class="math display">\[S_1 = 0, S_x =S_fa(x)+edge(x)\]</span></p><p>注意，查询结点 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 的路径和时，和点权略有不同：</p><p><span class="math display">\[S_x+S_y-2*S_{lca(x,y)}\]</span></p><p>因为实际上是边上的值，路径上的边并未重复，只有最近公共祖先到根节点的路径和是冗余的。</p><h4 id="子树和">子树和</h4><p>和数组的情形不同，由于树的首位不对称，所以自下而上（从树叶到树根）和自上而下（从树根到树叶），求<strong>前缀和</strong>得到的结果并不相同。一般<strong>树上前缀和</strong>指的是自上而下的前缀和。而另一种做法，实际上是得到结点子树的总和，本文称作<strong>子树和</strong>。</p><p>以点权为例，显然有</p><p><span class="math display">\[T_x = \sum\limits_{y\indesc(x)}a_z\]</span></p><p>其中, <span class="math inline">\(desc(x)\)</span> 表示 <spanclass="math inline">\(x\)</span> 自身和其所有子孙结点的集合</p><p>与树上前缀和不同，子树和并不能应用于 <spanclass="math inline">\(O(1)\)</span>求路径权值和，但是它可以用于理解下文的树上差分。</p><h2 id="差分">差分</h2><p>​与前缀和相对，是前缀和的逆运算。相较于给定某一序列求它的差分，竞赛中更为常见的情景是，通过维护差分序列的信息，实现多次区间修改。在区间修改结束后，可以通过前缀和恢复原序列的信息，实现对原序列的查询。注意修改操作一定要在查询操作之前。</p><h3 id="一维差分">一维差分</h3><p>为避免顺序冲突，从最末项往前开始构造差分</p><p><span class="math display">\[D_i = a_i-a_{i-1},a_0=0\]</span></p><p><strong>性质</strong></p><p>​ 差分的前缀和就是原数列，基于此可推出其与原数列前缀和的关系</p><p><spanclass="math display">\[S_i=\sum\limits_{j=1}^i\sum\limits_{k=1}^jD_k=\sum\limits_{j=1}^i(i-j+1)D_j\]</span></p><p>​差分信息常常用于维护多次对序列的一个区间加上一个数，并在之后一次或多次询问序列某一位的取值。</p><p>​ 假设要将序列 <span class="math inline">\({a_i}\)</span> 在区间 <spanclass="math inline">\([l,r]\)</span> 中的每个数加上一个 <spanclass="math inline">\(v\)</span> 。可以做如下操作：</p><p><span class="math display">\[D_l=D_l+v,\ D_{r+1}=D_{r+1}-v\]</span></p><p>​ 单次修改是 <span class="math inline">\(O(1)\)</span>的，查询需要做一次 <span class="math inline">\(O(n)\)</span>的前缀和操作，随后的查询都是 <span class="math inline">\(O(1)\)</span>的复杂度。</p><h3 id="二维多维差分">二维/多维差分</h3><p>​差分同样可以推广到多维的情形。将多维差分看作多维前缀和的逆运算，那么，求多维差分数组的操作就相当于根据多维前缀和求它的原数组。</p><p>​ 可以利用容斥原理，例如二维差分可用：</p><p><span class="math display">\[D_{i,j} =a_{i,j}-a_{i-1,j}-a_{i,j-1}+a_{i-1,j-1}\]</span></p><p>​但是，如果要计算整个差分数组，更为简单高效的做法是逐维差分，即穷举所有维度，沿着每个维度都计算一遍数组的差分。</p><p>​ 二维差分信息常用于维护二维数组的多次矩形加。例如，对左上角 <spanclass="math inline">\((x_1,y_1)\)</span> 、右下角 <spanclass="math inline">\((x_2,y_2)\)</span> 的矩阵中每个数字都加上 <spanclass="math inline">\(v\)</span> ，可做：</p><ul><li><span class="math inline">\(D_{x_1,y_1}\)</span> += <spanclass="math inline">\(v\)</span></li><li><span class="math inline">\(D_{x_1,y_2+1}\)</span> -= <spanclass="math inline">\(v\)</span></li><li><span class="math inline">\(D_{x_1+1,y_2}\)</span> -= <spanclass="math inline">\(v\)</span></li><li><span class="math inline">\(D_{x_1+1,y_2+1}\)</span> += <spanclass="math inline">\(v\)</span></li></ul><p>​在所有修改操作结束后，只需要执行一遍二维前缀和，就可以快速查询更新后的数组的值。</p><p>​ 注意，尽管修改操作适用于多维，但单次修改操作需要 <spanclass="math inline">\(O(2^k)\)</span> ，随着 <spanclass="math inline">\(k\)</span> 增大而不再实用</p><h3 id="树上差分">树上差分</h3><p>差分可推广到有根树的情形，用于实现树上一段路径的区间加操作。根据维护的信息存储在结点上还是边上，树上差分可以分为<strong>点差分</strong> 与<strong>边差分</strong>，它们在实现上会稍有不同。另外，相对于树上前缀和操作，更常用的是在所有修改操作后做子树和再查询。本节讨论的就是这种情形。</p><h4 id="点差分">点差分</h4><p>如果要对结点 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 之间的路径上的所有点权都加 <spanclass="math inline">\(v\)</span>，可以对它的差分序列 <spanclass="math inline">\({D_x}\)</span> 做如下操作：</p><ul><li>$D_x $ += <span class="math inline">\(v\)</span></li><li><span class="math inline">\(D_{lca(x,y)}\)</span>-= <spanclass="math inline">\(v\)</span></li><li>$D_y $ += <span class="math inline">\(v\)</span></li><li><span class="math inline">\(D_{fa(lca(x,y))}\)</span> -= <spanclass="math inline">\(v\)</span></li></ul><p>在所有修改操作完成后，可以计算一次子树和，就能得到更新后的点权。</p><h4 id="边差分">边差分</h4><p>如果要对结点 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 之间的路径上的所有边权都加 <spanclass="math inline">\(v\)</span> ，可以对它的差分序列 <spanclass="math inline">\({D_x}\)</span> 做如下操作:</p><ul><li><span class="math inline">\(D_x\)</span> += <spanclass="math inline">\(v\)</span></li><li><span class="math inline">\(D_y\)</span> += <spanclass="math inline">\(v\)</span></li><li><span class="math inline">\(D_{lca(x,y)}\)</span> -= <spanclass="math inline">\(2v\)</span></li></ul><h2 id="stl上的前缀和与差分">STL上的前缀和与差分</h2><p>有时，元素个数足够，但是需要做差分或前缀和的并非元素下标，而是元素值，此时数组长度往往不够用。那么可以利用STL里的数据结构来存放，比如<code>map</code> 类型。</p><blockquote><p>例题</p><p><ahref="https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/solutions/3803631/zhi-xing-cao-zuo-hou-yuan-su-de-zui-gao-n4uko/?envType=daily-question&amp;envId=2025-10-22">3347.执行操作后元素的最高频率 II - 力扣（LeetCode）</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxFrequency</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> numOperations)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)&#123;</span><br><span class="line">        cnt[i]++;</span><br><span class="line">        mp[i]; <span class="comment">//本身元素要参与</span></span><br><span class="line">        mp[i-k]++;</span><br><span class="line">        mp[i+k<span class="number">+1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t=mp.<span class="built_in">begin</span>();t!=mp.<span class="built_in">end</span>();t++)&#123;</span><br><span class="line">        <span class="type">int</span> i = t-&gt;first;</span><br><span class="line">        sum += mp[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">min</span>(sum,numOperations+cnt[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="离散化">离散化</h2><p>离散化是一种数据处理的技巧，本质上可以看成是一种<strong>哈希</strong>，其保证数据在哈希以后仍然保持原来的<strong>全序/偏序</strong> 关系。</p><p>通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便的处理，而最终影响结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照排名来处理问题，即离散化。</p><p>用来离散化的可以是大整数、浮点数、字符串等等。</p><h3 id="实现">实现</h3><p>将一个数组离散化，并进行查询是比较常用的应用场景。</p><p><strong>方法一</strong></p><p>通常原数组中会有重复的元素，一般把相同的元素离散化为相同的数据。</p><p>方法如下：</p><ol type="1"><li>创建原数组的副本</li><li>将副本中的值从小到大排序</li><li>将排序好的副本去重</li><li>查找原数组的每一个元素在副本中的位置，位置即为排名，将其作为离散化后的值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr[i]为初始数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    tmp[i = arr[i];</span><br><span class="line"><span class="built_in">sort</span>(tmp<span class="number">+1</span>,tmp+n<span class="number">+1</span>);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(tmp<span class="number">+1</span>,tmp+n<span class="number">+1</span>)-(tmp<span class="number">+1</span>); <span class="comment">//去重</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    arr[i] = <span class="built_in">lower_bound</span>(tmp<span class="number">+1</span>,tmp+len<span class="number">+1</span>,arr[i])-tmp.<span class="built_in">begin</span>(); <span class="comment">//给出排名并赋值</span></span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><p>根据题目要求，有时候会把相同的元素根据输入顺序离散化为不同的数据。</p><p>显然靠 <code>lower_bound()</code>函数实现就有些困难了，需要换一种思路：</p><ol type="1"><li>创建原数组的副本，同时记录每个元素出现的位置。</li><li>将副本按值从小到大排序，当值相同时，按出现顺序从小到大排序。</li><li>将离散化后的数字放回原数组</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> idx,val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Data&amp; o) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == o.val) <span class="keyword">return</span> idx&lt;o.idx;</span><br><span class="line">        <span class="keyword">return</span> val &lt; o.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tmp[MAXN]; <span class="comment">//pair亦可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) tmp[i] = Data&#123;i,arr[i]&#125;;</span><br><span class="line"><span class="built_in">sort</span>(tmp<span class="number">+1</span>,tmp+n<span class="number">+1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) arr[tmp[i].idx] = i;</span><br></pre></td></tr></table></figure><p><strong>复杂度</strong></p><p>对于方法一，去重复杂度为 <span class="math inline">\(O(n)\)</span>，排序复杂度为 <span class="math inline">\(O(nlogn)\)</span>，最后的<span class="math inline">\(n\)</span> 次查找复杂度为 <spanclass="math inline">\(O(nlogn)\)</span> 。</p><p>对于方法二，排序复杂度为 <spanclass="math inline">\(O(nlogn)\)</span>。</p><p>故两种方法的时间复杂度均为 <spanclass="math inline">\(O(nlogn)\)</span> ，空间复杂度为 <spanclass="math inline">\(O(n)\)</span> 。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>双指针</title>
      
      <link href="/2025/10/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/updating/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2025/10/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/updating/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针">双指针</h1><h2 id="引入">引入</h2><p>双指针是一种简单而又灵活的技巧和思想，单独使用可以轻松解决特定问题，和其他算法结合也能发挥多样的用途。</p><p>双指针顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过或同向移动，或相向移动来维护、统计信息。</p><h2 id="维护区间信息">维护区间信息</h2><p>如果不和其他数据结构结合使用，双指针维护区间信息的最简单模式就是维护具有一定单调性，新增和删去一个元素都很方便处理的信息，就比如正数的和、正整数的积等等。</p><p><strong>例题1</strong></p><blockquote><p><ahref="https://leetcode.cn/problems/subarray-product-less-than-k/">713.乘积小于 K 的子数组 - 力扣（LeetCode）</a></p><p>给定一个长度为 <span class="math inline">\(n\)</span> 的正整数数组<span class="math inline">\(nums\)</span> 和整数 <spanclass="math inline">\(k\)</span> ，找出该数组内乘积小于 <spanclass="math inline">\(k\)</span> 的连续子数组的个数。</p></blockquote><p><strong>过程</strong></p><p>设两个指针分别为 <span class="math inline">\(l,r\)</span>，另外一个变量 <span class="math inline">\(tmp\)</span> 记录 <spanclass="math inline">\([l,r]\)</span> 内所有数的乘积。最开始 <spanclass="math inline">\(l,r\)</span> 都在最左面，先向右移动 <spanclass="math inline">\(r\)</span> ，直到第一次发现 <spanclass="math inline">\(tmp \geq k\)</span> ，这时就固定 <spanclass="math inline">\(r\)</span> ，右移 <spanclass="math inline">\(l\)</span> ，直到</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>算法题中的神技</title>
      
      <link href="/2025/09/17/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E7%A5%9E%E6%8A%80/"/>
      <url>/2025/09/17/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E7%A5%9E%E6%8A%80/</url>
      
        <content type="html"><![CDATA[<h1 id="神技">神技</h1><blockquote><p>记录网上看到的，泛用性较强的解题神技，持续更新</p></blockquote><h2 id="前缀乘">前缀“乘”</h2><blockquote><p><ahref="https://leetcode.cn/problems/subarray-product-less-than-k/solutions/1463527/cheng-ji-xiao-yu-k-de-zi-shu-zu-by-leetc-92wl/">713.乘积小于 K 的子数组 - 力扣（LeetCode）</a></p></blockquote><p>往往前缀和，当用乘法表示加和时，是会很容易爆ll的，那么，我们可以通过<span class="math inline">\(log\)</span>对数将乘法转换成加法，把之转化成真正的前缀“和“。尽管，我们无法得到精确的值，但用来作为条件判断已经足够了</p><p>前缀和求解转化为</p><p>$ ps[i] = ps[i-1]+log(nums[i])$</p><p>求 <span class="math inline">\([l,r]\)</span> 的乘积小于 <spanclass="math inline">\(k\)</span> 可表示为</p><p><spanclass="math inline">\(ps[m]-ps[i-1]+10^{-10}&lt;logk\)</span></p><p>double 类型只能保证 <span class="math inline">\(15\)</span>位有效数字是精确的。为了避免计算带来的误差，相减后要加上 <spanclass="math inline">\(10^{-10}\)</span>（题目中的 double数值整数部分的数字不超过 5 个），从而防止不等式两边数值相等却被判定为大于的情况。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构-珂朵莉树</title>
      
      <link href="/2025/09/02/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/"/>
      <url>/2025/09/02/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="珂朵莉树">珂朵莉树</h1><blockquote><p>参考资料: <a href="https://oi-wiki.org/misc/odt/">珂朵莉树/颜色段均摊- OI Wiki</a></p></blockquote><p>珂朵莉树（Chtholly Tree），又称ODT。源自 <ahref="https://codeforces.com/problemset/problem/896/C">CF896C</a>。</p><p>这个名称指代的是一种使用 <strong>平衡树</strong> 或<strong>链表</strong>维护「颜色段均摊」的技巧，而不是一种特定的数据结构。其核心思想是将指相同的一段区间合并成一个结点处理。相较于传统的线段树等数据结构，对于含有区间覆盖的操作问题，珂朵莉树可以更加方便地维护每个被覆盖区间的值。</p><h2 id="实现stdset">实现（std::set）</h2><h3 id="结点类型">结点类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node_t</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> v; <span class="comment">//mutable能突破 const 的限制，使变量永远可变</span></span><br><span class="line">    <span class="built_in">Node_t</span>(<span class="type">const</span> <span class="type">int</span> &amp;il,<span class="type">const</span> <span class="type">int</span> &amp;ir,<span class="type">const</span> <span class="type">int</span> &amp;iv):<span class="built_in">l</span>(il),<span class="built_in">r</span>(ir),<span class="built_in">v</span>(iv)&#123;&#125; <span class="comment">//构造函数</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node_t &amp;o) <span class="type">const</span> &#123;<span class="keyword">return</span> l&lt;o.l;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<span class="math inline">\(v\)</span>为自己指定的附加数据。</p><h3 id="结点存储">结点存储</h3><p>我们希望维护所有结点，使得结点代表的区间左端点单调增加且两两不交，最好可以保证所有区间的并是一个极大的连续操作。此处以<code>std::set&lt;Node_t&gt;odt</code>；维护所有结点。显然，就需要初始化时插入区间 <spanclass="math inline">\([1,n]\)</span></p><h3 id="split-操作">split 操作</h3><p><code>split</code> 操作是珂朵莉树的核心。它接受一个位置 <spanclass="math inline">\(x\)</span> ，将原本包含点 <spanclass="math inline">\(x\)</span> 的区间（设为<spanclass="math inline">\([l,r]\)</span>） 分裂为两个区间 <spanclass="math inline">\([l,x)\)</span> 和 <spanclass="math inline">\([x,r]\)</span> ，并返回指向后者的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = odt.<span class="built_in">lower_bound</span>(<span class="built_in">Node_t</span>(x,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(it != odt.<span class="built_in">end</span>() &amp;&amp; it-&gt;l == x) <span class="keyword">return</span> it; <span class="comment">//刚好存在区间左端点为x,不需要分割区间</span></span><br><span class="line">    it--;</span><br><span class="line">    <span class="type">int</span> l = it-&gt;l, r = it-&gt;r, v = it-&gt;v;</span><br><span class="line">    odt.<span class="built_in">erase</span>(it); <span class="comment">//删掉原区间</span></span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">Node_t</span>(l,x<span class="number">-1</span>,v));</span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">Node_t</span>(x,r,v)).first; </span><br><span class="line">    <span class="comment">//插入操作返回的是一个pair对象，first表示插入元素(或已存在的相同元素)的迭代器，second是bool值，表示插入是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>auto</code>不支持的情况下，可使用对应的迭代器<code>set&lt;Node_t&gt;::iterator</code>。</p><h3 id="assign-操作">assign 操作</h3><p>另外一个重要的操作：<code>assign</code>。用于对一段区间进行赋值。设将要对区间 <spanclass="math inline">\([l,r]\)</span> 赋值为 <spanclass="math inline">\(v_0\)</span> 。</p><p>首先，将区间 <span class="math inline">\([l,r]\)</span>截取出来。依次调用 <code>split(r+1),split(l)</code>，将此两者返回的迭代器记作 <spanclass="math inline">\(itr,itl\)</span>，那么 <spanclass="math inline">\([itl,itr)\)</span> 这个迭代器，就指向了珂朵莉树中<span class="math inline">\([l,r]\)</span> 包含的所有区间。</p><p>然后，将原有的信息删除。<code>std::set</code> 有成员方法<code>erase</code> ，可按迭代器删除 <spanclass="math inline">\([first;last)\)</span> 中的元素，即调用<code>odt.erase(itl，itr)；</code></p><p>最后，插入区间 <span class="math inline">\([l,r]\)</span>的新值，调用 <code>insert()</code> 方法即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = <span class="built_in">split</span>(r<span class="number">+1</span>),itl = <span class="built_in">split</span>(l);</span><br><span class="line">    odt.<span class="built_in">erase</span>(itl,itr);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">Node_t</span>(l,r,v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>先调用 <span class="math inline">\(split(r+1)\)</span> 是为了防止删去<span class="math inline">\(split(l)\)</span> 产生的 <spanclass="math inline">\(l\)</span> 为左端点的区间。</p></blockquote><h3 id="perform-操作">perform 操作</h3><p>提取区间并进行操作，和 <code>assign</code>操作类似。有时题目要求的操作可以不用到 <code>split</code>时（像区间赋值就不得不用），尽量避免使用 <code>split</code>转而用查找方法代替。（避免过度分割区间，但一般数据随机时无事）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">perform</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = <span class="built_in">split</span>(r<span class="number">+1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)&#123;</span><br><span class="line">        <span class="comment">//perform操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现stdmap">实现（std::map）</h2><p>相较于 <code>std::set</code> 的实现，<code>std::map</code> 的实现的<code>split</code> 操作写法更简单。</p><h3 id="结点存储-1">结点存储</h3><p>由于珂朵莉树存储的区间是连续的，我们不一定要记下右端点是什么。不妨使用<code>map&lt;int,int&gt; mp;</code>存储所有区间，其键维护左端点，其值维护<strong>对应的左端点到下一个左端点之前的值</strong>。</p><p>初始化时，如题目要求维护位置 <span class="math inline">\(1\)</span>到 <span class="math inline">\(n\)</span> 的信息，则调用 <spanclass="math inline">\(mp[1] = -1\)</span> ，<spanclass="math inline">\(mp[n+1]=-1\)</span> 表示将 <spanclass="math inline">\([1,n+1)\)</span> 即 <spanclass="math inline">\([1,n]\)</span> 都设为特殊值 <spanclass="math inline">\(-1\)</span>，<spanclass="math inline">\([n+1,+\infty)\)</span>这个区间当作哨兵使用，也可以对它进行初始化。</p><h3 id="split-操作-1">split 操作</h3><p>参考代码：（第一份）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//upper_bound 是找到第一个大于x的点</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">prev</span>(mp.<span class="built_in">upper_bound</span>(x)); <span class="comment">//找到左端点小于等于 x 的区间 </span></span><br><span class="line">    mp[x] = it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考代码：（第二份）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">prev</span>(mp.<span class="built_in">upper_bound</span>(x));</span><br><span class="line">    <span class="keyword">return</span> mp.<span class="built_in">insert</span>(it,<span class="built_in">make_pair</span>(pos,it-&gt;second)); <span class="comment">//附上被分割区间的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="assign-操作-1">assign 操作</h3><p>对于 <code>assign</code> 操作，我们需要把 <spanclass="math inline">\([l,r-1]\)</span>内所有区间左端点删除，再建立新的区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">split</span>(l);</span><br><span class="line">    <span class="built_in">split</span>(r);</span><br><span class="line">    <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(l);</span><br><span class="line">    <span class="keyword">while</span>(it-&gt;first != r)&#123;</span><br><span class="line">        it = mp.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    mp[l] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="perform-操作-1">perform 操作</h3><p>对于 <code>perform</code> 操作，和 <code>assign</code> 大致相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">perform</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">split</span>(l);</span><br><span class="line">    <span class="built_in">split</span>(r);</span><br><span class="line">    <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(l);</span><br><span class="line">    <span class="keyword">while</span>(it-&gt;first!=r)&#123;</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        it = <span class="built_in">next</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现链表">实现（链表）</h2><p>详见<ahref="https://oi-wiki.org/misc/odt/#实现链表">珂朵莉树/颜色段均摊 - OIWiki</a></p><h2 id="关于时间复杂度">关于时间复杂度</h2><p>​ 显然，由于 <code>perform</code> 操作调用的两次 <code>split</code>至多增加两个区间，而 <code>assign</code>操作会删除范围的所有区间（显然包括其<code>split</code>操作所增加的区间），并再增加一个区间。因此，当数据随机时，复杂度才能保证正确。详见<ahref="http://codeforces.com/blog/entry/56135?#comment-398940">Codeforces上关于珂朵莉树的复杂度的证明</a>。更详细的严格证明见 <ahref="https://zhuanlan.zhihu.com/p/102786071">珂朵莉树的复杂度分析</a>。证明的结论是：用<code>std::set</code> 实现的珂朵莉树的复杂度为 <spanclass="math inline">\(O(n loglogn)\)</span> ，而用链表实现的复杂度为<span class="math inline">\(O(n logn)\)</span> 。</p><p>​如果允许特殊构造数据，这样一定是能被卡掉的，只需要使珂朵莉树中有足够多的不同区间并反复遍历，就能使珂朵莉树的复杂度达到甚至高于平方级别。</p><p>​ 但如果存在这样的情况：元素的种类足够少，<code>assign</code>操作可能使得其与相邻区间值相同，那么就可以通过一系列操作合并相同值区间，笔者做<ahref="https://www.luogu.com.cn/problem/P4979">P4979 矿洞：坍塌 -洛谷</a> 时突发灵感。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考代码</span></span><br><span class="line"><span class="comment">//node为上文的Node_t</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(set&lt;node&gt;::iterator a)</span></span>&#123; <span class="comment">//查看是否能合并周围结点，如果能就合并</span></span><br><span class="line">    <span class="keyword">auto</span> l = a,r = <span class="built_in">next</span>(a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prev</span>(a)-&gt;v == a-&gt;v)&#123;</span><br><span class="line">        l = <span class="built_in">prev</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">next</span>(a)-&gt;v == a-&gt;v)&#123;</span><br><span class="line">        r = <span class="built_in">next</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">next</span>(l) != r)&#123;</span><br><span class="line">        <span class="type">int</span> il = l-&gt;l,ir = <span class="built_in">prev</span>(r)-&gt;r,iv = l-&gt;v;</span><br><span class="line">        odt.<span class="built_in">erase</span>(l,r);</span><br><span class="line">        odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(il,ir,iv));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，当使用类似 <code>assign</code> 操作等，其末尾可使用<code>merge</code> 操作。</p><h2 id="原题ac代码">原题AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,seed,vmax;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">long</span> <span class="type">long</span> v;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> &amp;il,<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> &amp;ir,<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> &amp;iv):<span class="built_in">l</span>(il),<span class="built_in">r</span>(ir),<span class="built_in">v</span>(iv)&#123;&#125;; </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;o) <span class="type">const</span> &#123;<span class="keyword">return</span> l&lt;o.l;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">struct</span> node&gt; odt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = odt.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(x,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(it!=odt.<span class="built_in">end</span>()&amp;&amp;it-&gt;l == x) <span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l=it-&gt;l,r=it-&gt;r,v=it-&gt;v;</span><br><span class="line">    odt.<span class="built_in">erase</span>(it);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,x<span class="number">-1</span>,v));</span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(x,r,v)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> itl=<span class="built_in">split</span>(l);</span><br><span class="line">    odt.<span class="built_in">erase</span>(itl,itr);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr=<span class="built_in">split</span>(r<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> itl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)&#123;</span><br><span class="line">        itl-&gt;v += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perform1</span><span class="params">(<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = <span class="built_in">split</span>(r<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> itl = <span class="built_in">split</span>(l);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)&#123;</span><br><span class="line">        pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt; pr;</span><br><span class="line">        pr.first = itl-&gt;v;</span><br><span class="line">        pr.second = itl-&gt;r - itl-&gt;l<span class="number">+1</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(pr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; v[i].second)&#123;</span><br><span class="line">            x -= v[i].second;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; v[i].first &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> v,<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            res = res * v % y; </span><br><span class="line">        &#125;</span><br><span class="line">        v = v*v % y;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perform2</span><span class="params">(<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = <span class="built_in">split</span>(r<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> itl = <span class="built_in">split</span>(l);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;itl++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l=itl-&gt;l,r=itl-&gt;r,v=itl-&gt;v;</span><br><span class="line">        res += (<span class="built_in">qpow</span>(v%y,x,y)*((r-l<span class="number">+1</span>)))%y;</span><br><span class="line">        res %= y;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret = seed;</span><br><span class="line">    seed = (seed * <span class="number">7</span> + <span class="number">13</span>) % <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(<span class="number">1</span>,n<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i] = (<span class="built_in">rnd</span>() % vmax) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">assign</span>(i,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> op = (<span class="built_in">rnd</span>() % <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l = (<span class="built_in">rnd</span>() % n) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> r = (<span class="built_in">rnd</span>() % n) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x,y;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">            x = (<span class="built_in">rnd</span>() % (r - l + <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = (<span class="built_in">rnd</span>() % vmax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">4</span>)</span><br><span class="line">            y = (<span class="built_in">rnd</span>() % vmax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">add</span>(l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">assign</span>(l,r,x);   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="built_in">perform1</span>(l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>) <span class="built_in">perform2</span>(l,r,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 珂朵莉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>排序-归并排序</title>
      
      <link href="/2025/09/02/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/09/02/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><h2 id="定义">定义</h2><p>归并排序（merge sort）是高效的基于比较的稳定排序算法</p><h2 id="性质">性质</h2><p>归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为<span class="math inline">\(O(nlogn)\)</span>，空间复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><p>归并排序可以只使用 <span class="math inline">\(O(1)\)</span>的辅助空间，但为便捷通常使用与原数组等长的辅助数组。</p><h2 id="过程">过程</h2><h3 id="合并">合并</h3><p>归并排序最核心的部分是 合并（merge）过程：将两个有序的数组 <spanclass="math inline">\(a[i]\)</span> 和 <spanclass="math inline">\(b[i]\)</span> 合并为一个有序数组 <spanclass="math inline">\(c[k]\)</span>。</p><p>从左往右枚举 <span class="math inline">\(a[i]\)</span> 和 <spanclass="math inline">\(b[j]\)</span>，找出最小的值并放入数组 <spanclass="math inline">\(c[k]\)</span>；重复上述过程直到 <spanclass="math inline">\(a[i]\)</span> 和 <spanclass="math inline">\(b[j]\)</span>有一个为空时，将另一个数组剩下的元素放入 <spanclass="math inline">\(c[k]\)</span> 。</p><p>为保证排序的稳定性，前段首元素小于或等于后端首元素时（<spanclass="math inline">\(a[i]\leq b[j]\)</span>）而非小于时（<spanclass="math inline">\(a&lt;b\)</span>），就要作为最小值放入 <spanclass="math inline">\(c[k]\)</span></p><p>数组实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *a, <span class="type">int</span> aLen, <span class="type">const</span> <span class="type">int</span> *b, <span class="type">int</span> bLen, <span class="type">int</span> *c)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; aLen &amp;&amp; j &lt; bLen) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b[j] &lt; a[i]) &#123;  <span class="comment">// &lt;!&gt; 先判断 b[j] &lt; a[i]，保证稳定性</span></span><br><span class="line">      c[k] = b[j];</span><br><span class="line">      ++j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c[k] = a[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时一个数组已空，另一个数组非空，将非空的数组并入 c 中</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; aLen; ++i, ++k) c[k] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; bLen; ++j, ++k) c[k] = b[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分治法实现归并排序">分治法实现归并排序</h3><ol type="1"><li>当数组长度为 <span class="math inline">\(1\)</span>时，该数组就已经是有序的，不用再分解。</li><li>当数组长度大于 <span class="math inline">\(1\)</span>时，该数组很可能是不是有序的。此时将该数组分为两段，再分别检查两个数组是否有序。如果有序，则将它们合并为一个有序数组；否则对不有序的数组重复第<span class="math inline">\(2\)</span> 条，再合并。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,mid,r);</span><br><span class="line">    <span class="type">int</span> tmp[<span class="number">10010</span>] = &#123;&#125;; <span class="comment">//结合实际情况设置tmp长度（与a相同）</span></span><br><span class="line">    <span class="built_in">merge</span>(a+l,mid-l,a+mid,r-mid,tmp+l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;r;i++) a[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="倍增法实现归并排序">倍增法实现归并排序</h3><p>已知当数组长度为 <span class="math inline">\(1\)</span>时，该数组就是已经有序的。</p><p>将数组全部切成长度为 <span class="math inline">\(1\)</span>的段。</p><p>从左往右依次合并两个长度为 <span class="math inline">\(1\)</span>的有序段，得到一系列长度 <span class="math inline">\(\leq2\)</span>的有序段；</p><p>从左往右依次合并两个长度为 <span class="math inline">\(\leq2\)</span> 的有序段，得到一系列长度 <span class="math inline">\(\leq4\)</span> 的有序段；</p><p>从左往右依次合并两个长度为 <span class="math inline">\(\leq4\)</span> 的有序段，得到一系列长度 <spanclass="math inline">\(\leq8\)</span> 的有序段；</p><p>……</p><p>重复上述过程，直至数组只剩一个有序段，该段就是排序好的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp[<span class="number">1024</span>]=&#123;&#125;; <span class="comment">//结合情况设置大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> seg = <span class="number">1</span>; seg&lt;n; seg&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l1 = <span class="number">0</span>;l1 &lt; n-seg;l1 += <span class="number">2</span>*seg)&#123;</span><br><span class="line">            <span class="type">int</span> r1 = l1 + seg;</span><br><span class="line">            <span class="type">int</span> l2 = r1;</span><br><span class="line">            <span class="type">int</span> r2 = <span class="built_in">min</span>(l2+seg,n);</span><br><span class="line">            <span class="built_in">merge</span>(a+l1,a+r1,a+l2,a+r2,tmp+l1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l1;i&lt;r2;i++) a[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>算法基础-倍增</title>
      
      <link href="/2025/08/28/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%80%8D%E5%A2%9E/"/>
      <url>/2025/08/28/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%80%8D%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://oi-wiki.org/basic/binary-lifting/">倍增 -OI Wiki</a></p></blockquote><h1 id="倍增">倍增</h1><h2 id="定义">定义</h2><p>倍增法（binarylifting），即“成倍增长”的含义。我们在进行递推时，如果状态空间很大，那么通常的线性递推无法满足空间和时间复杂度的要求。那么，我们可以通过成倍增长的方式，只递推状态空间中在<span class="math inline">\(k\)</span>的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过<strong>k的一元多项式之和</strong>得到。所以使用倍增算法也要求我们递推的问题的状态空间关于<span class="math inline">\(k\)</span> 的次幂具有可划分性。通常情况下<span class="math inline">\(k\)</span> 取 <spanclass="math inline">\(2\)</span> （这样每项的系数要么为 <spanclass="math inline">\(1\)</span> ，要么为 <spanclass="math inline">\(0\)</span> ）</p><h2 id="应用">应用</h2><h3 id="rmq问题">RMQ问题</h3><p><strong>RMQ</strong> 是 Range Maximum/Minimum Query的缩写，表示区间最大（最小）值 。使用 <strong>ST表</strong>是基于倍增思想的 <strong>RMQ问题</strong> 求解方式</p><h3 id="树上倍增求lca">树上倍增求LCA</h3><p>求最近公共祖先的倍增解决方式</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>图论-DFS/BFS</title>
      
      <link href="/2025/08/14/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA-DFS%E4%B8%8EBFS/"/>
      <url>/2025/08/14/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA-DFS%E4%B8%8EBFS/</url>
      
        <content type="html"><![CDATA[<h1 id="图论-dfsbfs">图论-DFS/BFS</h1><blockquote><p>参考资料: <a href="https://oi-wiki.org/graph/dfs/">DFS（图论） - OIWiki</a></p></blockquote><h2 id="深度优先搜索dfs">深度优先搜索DFS</h2><h3 id="引入">引入</h3><p>​ 深度优先搜索 <strong>(Depth First Search)</strong>，简称<strong>深搜</strong> 或者<strong>DFS</strong>，是一种用于遍历或搜索树或图的算法。顾名思义，深搜就是每次向着下一层次的搜索。</p><p>​ 与之相对的是 <strong>BFS</strong> ,但两者除了遍历图的连通块以外，用途完全不同。</p><h3 id="过程">过程</h3><p>​ DFS 最关键的地方就是通过栈实现 “回退”至上一结点以遍历同一层次的结点，我们也可以通过递归实现(这是主流用法)，毕竟递归是依靠栈实现的。访问每个结点时得为其打上标记，避免重复访问。</p><p>​ 显然我们可以得到这样一个DFS结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dfs(v)&#123;//v为图中的一个顶点，有时也可以是其他抽象的概念，如dp状态</span><br><span class="line">//标记v    </span><br><span class="line">    for u in v相邻的结点&#123;</span><br><span class="line">    if 如果u没有标记</span><br><span class="line">    dfs(u) //递归访问u结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性质">性质</h3><p>​ 该算法通常的时间复杂度为 <span class="math inline">\(O(n+m)\)</span>，空间复杂度为 <span class="math inline">\(O(n)\)</span>, 其中 <spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数。在平均 <spanclass="math inline">\(O(1)\)</span>遍历一条边的条件下才能到达这个时间复杂度，例如用前向星和邻接表存储图。</p><h3 id="实现">实现</h3><p>这里假设使用邻接表存储图</p><p><strong>递归实现</strong>(常用)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g; <span class="comment">//邻接表</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; visited; <span class="comment">//标记结点是否被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123; <span class="comment">//从u开始遍历图的连通块</span></span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈实现</strong></p><blockquote><p>以下代码来自OI Wiki</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;  <span class="comment">// 邻接表</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;         <span class="comment">// 记录节点是否已经遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">  st.<span class="built_in">push</span>(s);</span><br><span class="line">  vis[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = st.<span class="built_in">top</span>();</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;  <span class="comment">// 确保栈里没有重复元素</span></span><br><span class="line">        st.<span class="built_in">push</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索bfs">广度优先搜索BFS</h2><h3 id="引入-1">引入</h3><p>​ 广度优先搜索 <strong>(Breadth FirstSearch)</strong>，又称宽度优先搜索，一般简称 <strong>宽搜</strong>或者<strong>BFS</strong>。BFS追求先遍历完所有子结点，再去遍历子节点的子结点，即每次先访问完同一层的结点。显然，BFS所找到的路径一定是最短的路径 <em>(此处最短指含边最少)</em> 。 BFS一般用<strong>队列</strong> 实现。</p><h3 id="实现-1">实现</h3><p>​将子结点(最开始是根结点)先放入队列，在通过队列全部访问，中途也会访问到子结点的子节点，这时将它们队列，那么当子节点那一层访问完毕时，我们就可以开始访问子节点的子节点了(相对的下一层)。当队列为空时，BFS结束。</p><p>先给出伪代码，理解BFS的实现过程，这方式和DFS栈的实现方法类似。</p><blockquote><p>以下代码均基于OI Wiki</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bfs(s) &#123;</span><br><span class="line">  q = new queue() //创建队列</span><br><span class="line">  q.push(s), visited[s] = true //放入当前元素并标记</span><br><span class="line">  while (!q.empty()) &#123;</span><br><span class="line">    u = q.pop() //取出队列元素</span><br><span class="line">    for each edge(u, v) &#123; //遍历基于u的边</span><br><span class="line">      if (!visited[v]) &#123;</span><br><span class="line">      visited[v] = true</span><br><span class="line">        q.push(v) //放入队列</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++中基于链式前向星的存图方式的BFS实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) Q.<span class="built_in">pop</span>(); <span class="comment">//清空队列，以作下用</span></span><br><span class="line">  Q.<span class="built_in">push</span>(u); <span class="comment">//放入结点u</span></span><br><span class="line">  vis[u] = <span class="number">1</span>; <span class="comment">//标记u</span></span><br><span class="line">  d[u] = <span class="number">0</span>; <span class="comment">//用以记录最短距离，视情况用</span></span><br><span class="line">  p[u] = <span class="number">-1</span>; <span class="comment">//记录是从哪个节点走到当前节点的</span></span><br><span class="line">  <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    u = Q.<span class="built_in">front</span>(); <span class="comment">//得到队首u</span></span><br><span class="line">    Q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">//可在外嵌套一层while(!Q.size()),就成了树的BFS遍历（知道层数）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123; <span class="comment">//访问连接u的边</span></span><br><span class="line">      <span class="keyword">if</span> (!vis[e[i].to]) &#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(e[i].to); <span class="comment">//放入队列</span></span><br><span class="line">        vis[e[i].to] = <span class="number">1</span>;</span><br><span class="line">        d[e[i].to] = d[u] + <span class="number">1</span>; <span class="comment">//显然多一条边，距离就+1</span></span><br><span class="line">        p[e[i].to] = u; <span class="comment">//途径此边</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v = x; v != <span class="number">-1</span>; v = p[v]) &#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res[i]);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>OJ选题集</title>
      
      <link href="/2025/05/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/OJ%E9%80%89%E9%A2%98%E9%9B%86/"/>
      <url>/2025/05/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/OJ%E9%80%89%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下列OJ平台仅代表题目信息的一个出处，不一定为OJ平台原创</p></blockquote><blockquote><p>每道题下面的均为其中关键的解题思路，题目大意并非完整题目，只出现解题思路中需要的变量。</p><p>（因此，基于测试用例t等无关变量将不会出现）</p></blockquote><p>各题出处如下：</p><ul><li><a href="#cf">Codeforces</a></li><li><a href="#luogu">洛谷</a></li><li><a href="#力扣">力扣</a></li><li><a href="#码蹄集OJ(百度)">码蹄集OJ(百度)</a></li><li><a href="#蓝桥杯">蓝桥杯</a></li><li><a href="#其他">其他</a></li></ul><h1 id="codeforces"><span id="cf"data-wrapper="1">Codeforces</span></h1><h2 id="cherry-bomb">Cherry Bomb</h2><blockquote><p>Codeforces Round 1020 div.3 C. Cherry Bomb <ahref="https://codeforces.com/contest/2106/problem/C">Problem - C -Codeforces</a></p><p>tags: greedy math sortings *1000</p></blockquote><details>    <summary>题目大意</summary>    <p>两个非负整数数组a与b，当我们称其互补时，当且仅当对于每个编号i，均有a<sub>i</sub>+b<sub>i</sub>= x, 其中x为一定值。我们希望数组a,b的每个元素均非负且不大于k,并且a与b是互补的。接下来，会给出n和k、完整的数组a，以及不完整的数组b，不完整的地方用-1补齐，请问有多少种填充b的办法满足我们的需要。</p></details>​   核心是如何确定互补值的值域，或者minb、maxb的值域<hr /><h2 id="fashionable-array">Fashionable Array</h2><blockquote><p>Codeforces Round 1026 Div.2 A. Fashionable Array</p><p><a href="https://codeforces.com/contest/2110/problem/A">Problem - A -Codeforces</a></p></blockquote><details>    <summary>题目大意</summary>    给一个数组，问通过每次消灭任意一个元素，如何得到(max+min)%2==0的“时尚”数组。</details>​   对数组排序，可证明要么开始成功，要么只用从左往右，或者从右往左，找到第一个与 $max$ 或 $min$ 奇偶性不同的值，最大次数是遍历到 $min$ 或 $max$ （消除到只剩一个）。其中奇偶性不同的判断为 $(a+b)\%2=1$ ，结果对从左往右和从右往左搜索的结果取最小值。<hr /><h2 id="down-with-brackets">Down with Brackets</h2><blockquote><p>Codeforces Round 1026 Div.2 B. Down with Brackets</p><p><a href="https://codeforces.com/contest/2110/problem/B">Problem - B -Codeforces</a></p><p>tags: strings</p></blockquote><details>    <summary>题目大意</summary>    <p>给你一个良好顺序的括号字符串s，你能任意破坏一个左括号和右括号，是否破坏完后能使顺序不良好。良好顺序具体定义如下：1.可以是空集。2.如果A顺序良好，则(A)顺序良好。3.如果A、B顺序良好，则AB顺序良好</p></details><p>​ 我们发现如果存在同等级括号，如 <spanclass="math inline">\(ABC\)</span> 型，则从其中任意两个不同的括号集合如<span class="math inline">\(AB\)</span>中分别取括号，那么就破坏了两者的良好性，如果没有干扰，我们知道这不符合定义3，故不良好。</p><p>​但这实现困难并且存在干扰：如果等级并非最高的，即外面有括号包住，如（<spanclass="math inline">\(ABC\)</span>），我们发现取出的括号会被外面的括号补充，这是不行的。</p><p>​事实上，我们发现只用判断是否第一个括号和最后一个括号相对应即可，真则不能，假则能。</p><hr /><h2 id="vladik-and-fractions">Vladik and fractions</h2><blockquote><p>Codeforces Round 384 (Div. 2) C. Vladik and fractions</p><p><a href="https://codeforces.com/problemset/problem/743/C">Problem -743C - Codeforces</a></p><p>题目大意:</p><p>构造一组互不相同的 <span class="math inline">\(x,y,z\)</span> ,使得<span class="math inline">\(\frac{1}{x} + \frac{1}{y}+\frac{1}{z} =\frac{2}{n}\)</span></p></blockquote><p><span class="math inline">\(n = 1\)</span> 时无解，其它则有通解 <spanclass="math inline">\(n、n+1、n(n+1)\)</span></p><p>通解证明简单，带入即可。</p><hr /><h2 id="cool-partition">Cool Partition</h2><blockquote><p><a href="https://codeforces.com/contest/2117/problem/C">Problem - C -Codeforces</a></p><p>核心：贪心+双map模拟区间</p></blockquote><details>    <summary>题目大意</summary>    将一个区间划为两个区间时，如前一区间的元素全部出现在后一区间，我们称这一次切割为有效切割。试问对于给定的区间，通过有效切割得到的区间个数的最大值。</details><p>这是一道贪心题，只要最先就能做有效切割就做(即让前一区间元素尽量少)，显然开始就把第一个元素当作第一个区间，然后这样遍历（我们设前一区间为mp1，后一区间为mp2，原数组为a）:</p><ul><li>从 <span class="math inline">\(mp1\)</span> 中删去 <spanclass="math inline">\(a[i]\)</span>，表示无需再检查这一元素</li><li>在 <span class="math inline">\(mp2\)</span> 中加入 <spanclass="math inline">\(a[i]\)</span> ，表示后一区间已有该元素</li><li>如果 <span class="math inline">\(mp1\)</span> 为空，说明 <spanclass="math inline">\(mp2\)</span>已满足所有前一区间元素，立刻划分，并且 <spanclass="math inline">\(mp2\)</span> 成为下一 <spanclass="math inline">\(mp1\)</span>，并清空 <spanclass="math inline">\(mp2\)</span>。</li></ul><hr /><h2 id="add-0-or-k">Add 0 or K</h2><blockquote><p><a href="https://codeforces.com/problemset/problem/2134/B">Problem -2134B - Codeforces</a></p><p>tags: constructive algorithms math number theory</p></blockquote><details>    <summary>题目大意</summary>    对给定数组a，正整数k，可做至多k次的操作：对每个a中元素可选择加0还是k，全部加上一轮算一次操作，最后使得gcd(a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>)>1 。</details><p>显然，可将题中问题转化为，使得</p><p><span class="math inline">\(gcd(a_1+c_1k,a_2+c_2k,...a_n+c_nk)&gt;1,c_i\in[0,k]\)</span></p><p>至少两种解法，这里分别举出构造和数论的两个例子:</p><ul><li><p>构造 <span class="math inline">\(c_i\equiv{a_i}\pmod{k+1}\)</span> 即可，显然能使得最大公约数为 <spanclass="math inline">\(k+1\)</span></p></li><li><p>找到一个最小且非 <span class="math inline">\(k\)</span>的因数的质数 <span class="math inline">\(p\)</span>作为最大公约数，利用数论知识求解</p><p><span class="math display">\[c_i\cdot k+a_i \equiv 0 \pmod{p}\Longrightarrow c_i\equiv (-a_i \cdot k^{-1})\pmod{p}\]</span></p><p>解出 <span class="math inline">\(c_i\)</span> 即可。</p></li></ul><h2 id="cake-assignment">Cake Assignment</h2><blockquote><p><a href="https://codeforces.com/contest/2139/problem/C">Problem - C -Codeforces</a></p><p>tags: <code>bitmasks</code> <code>constructive algorithms</code><code>greedy</code></p></blockquote><details>    <summary>题目大意</summary>    <p>起初，二人A、B分别有2<sup>k</sup>个cake，它们可以任意次数地给对方自己的一半（仅当它们有偶数个cake时），请问若想使得A有x个cake，该如何分配？1表示A给B一半，2反之。</p></details><p>显然，我们把A、B所拥有的cake描述为状态 <spanclass="math inline">\((a,b)\)</span> 。那么，这里的核心思路是：from thefinal state to backtrack。如果存在答案，那么显然我们期望的最终状态是<span class="math inline">\((x,2^{k+1}-x)\)</span>。我们从最终状态开始，如果当前A的数大于B的数，那么说明，上一步操作中，是B把数分一半给了A；反之亦然。注意答案和得到的是顺序相反的，可使用栈存储。</p><h1 id="洛谷"><span id="luogu" data-wrapper="1">洛谷</span></h1><h2 id="绿开关">[绿]开关</h2><blockquote><p>[P3870 <a href="https://www.luogu.com.cn/problem/P3870">TJOI2009]开关 - 洛谷</a></p><p>tags: 线段树 分块</p></blockquote><details><summary>题目大意</summary>    <p>有n盏灯排一排，能做两种操作,指定一个区间[a,b]，即可以要求输出区间打开的灯数，也可以改变该区间灯的状态（开的关，关的开），灯泡在初始时是关着的。</p>    <p>n,m 表示灯数与操作数</p><p>c表示操作种类（c=0为第一种，c=2为第二种）,a,b,表示指定区间    </p></details><p>​ 这是一个线段树的问题，线段树如何实现这里不做叙述，可见<ahref="https://blog.4fgr.xyz/2025/04/03/数据结构-线段树/">数据结构-线段树| 4FGR の Blog</a></p><p>​ 关键是如何处理操作1，即如何改变灯泡状态。</p><p>​考虑到灯泡只有两种状态，要么开，要么关，由于我们要求开着的灯泡数量，于是置开为1，关为0，对区间做操作1，实际上是对区间每个编号的值异或1的结果(1异或1为0，由开为观；0异或1为1，由关为开)，注意更新lazy标记的办法也是自异或1(lazy初始为0，01表示是否区间需要翻转)。</p><hr /><h2 id="黄跳石头">[黄]跳石头</h2><blockquote><p>[P2678 <a href="https://www.luogu.com.cn/problem/P2678">NOIP 2015提高组] 跳石头 - 洛谷</a></p><p>tags: 贪心 二分</p><p>核心：二分答案</p></blockquote><details>    <summary>题目大意</summary>    举办跳石头大赛，从起点到终点的距离是S，其中有N个石头，第i个石头离终点的距离为a<sub>i</sub>，举办方打算移除M个石头，求出可实现的最短跳跃距离的最大值。</details><p>​ 我们看到，答案一定确定在 <span class="math inline">\([1,S]\)</span>,并且问题是求最小值的最大值，这时候我们求可以用二分答案来求解。</p><p>​二分答案，顾名思义，依靠对答案的二分解出最后的答案，因此答案序列得是有序的且有界限，一般可用来解最小值的最大值，或者最大值的最小值。我们用<span class="math inline">\(judge\)</span> 函数每次评判中间值 <spanclass="math inline">\(mid\)</span>，如果成功，说明这个答案是合法解，最优解要么是它本身，要么就在它右边，若不合法，答案一定在它左边。随时用<span class="math inline">\(ans\)</span> 跟进合法的 <spanclass="math inline">\(mid\)</span>，显然答案就是最后一个判定为合法的<span class="math inline">\(mid\)</span>。</p><p>​ 对于这道题而言,（由于我们用 <span class="math inline">\(l\)</span> ,<span class="math inline">\(r\)</span>表示左右，因此文中的起点到终点的距离用s表示），答案一定在区间 <spanclass="math inline">\([1,s]\)</span> 上，我们每次取中间值 <spanclass="math inline">\(mid\)</span>，放入评判函数中。<spanclass="math inline">\(judge\)</span>函数如何设置呢？我们遍历每个石头的距离，如果这个距离小于 <spanclass="math inline">\(mid\)</span>，显然这块石头需要被捡走(不然不满足最短距离为<span class="math inline">\(mid\)</span>的条件)，记录石头被捡走的次数，如果这个次数比 <spanclass="math inline">\(m\)</span>(我们本应捡走的)要多，说明不是合法解，否则是合法解。</p><hr /><h2 id="橙小a的糖果">[橙]小A的糖果</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3817#ide">P3817 小A的糖果- 洛谷</a></p><p>tags: 模拟 贪心</p></blockquote><p>​题意：对多盒糖果，每次任意吃其中一颗糖果，使得相邻盒子中的糖果数不超过x，求出最少次数。</p><p>贪心问题，将问题拆分成子问题考虑，使得子问题最优的同时，尽力方便后续子问题。这里从第一个非头结点开始，先减当前位，不够再减前一位即可。</p><hr /><h2 id="橙subsequences-summing-to-sevens-s">[橙]Subsequences Summing toSevens S</h2><blockquote><p>[P3131 <a href="https://www.luogu.com.cn/problem/P3131">USACO16JAN]Subsequences Summing to Sevens S - 洛谷</a></p><p>tags: 前缀和</p></blockquote><p>使前缀和数组对 <span class="math inline">\(7\)</span>取模，这样余数相同的数之间组成的区间和均可被 <spanclass="math inline">\(7\)</span>整除，记录余数第一次出现的下标和最后一次的下标，注意对余数 <spanclass="math inline">\(0\)</span> 有特殊处理。</p><hr /><h2 id="橙最大正方形">[橙]最大正方形</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1387">P1387 最大正方形 -洛谷</a></p><p>tags: DP 枚举 前缀和</p></blockquote><p>有对应的三种做法</p><ul><li><p>通过二维前缀和，利用容斥原理求出区域和是否为边长平方，并逐步搜索，时间复杂度为<spanclass="math inline">\(O(nm\times\min(n,m))\)</span></p></li><li><p>二分答案，由于要求出最大边长 <spanclass="math inline">\(ans\)</span>，大于$ ans$ 肯定不存在，小于 <spanclass="math inline">\(ans\)</span> 的一定符合条件。那么，区间就锁定在<span class="math inline">\([1,min(n,m)]\)</span> ,之后依据暴力即可。同时可结合二维前缀和，将时间复杂度优化至 <spanclass="math inline">\(O(nm\times\log_2{\min(n,m))}\)</span></p></li><li><p>使用动态规划DP，状态转移方程为</p></li></ul><p>​ <span class="math display">\[dp[i][j] =min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1\]</span></p><p>​ 当 <span class="math inline">\(a[i][j]\)</span> 等于 <spanclass="math inline">\(1\)</span> 时，否则 <spanclass="math inline">\(dp[i ][j]\)</span>为 <spanclass="math inline">\(0\)</span> 。<spanclass="math inline">\(dp[i][j]\)</span> 表示以 <spanclass="math inline">\((i,j)\)</span>为正方形的右下顶点所能组成的最大正方形，借由该点的左边、上边、对角点各自的最大三角形，可以组成其自身的最大三角形。时间复杂度最小，为<spanclass="math inline">\(O(nm)\)</span>。</p><hr /><h2 id="绿贴海报">[绿]贴海报</h2><blockquote><p>[P3740 <a href="https://www.luogu.com.cn/problem/P3740">HAOI2014]贴海报 - 洛谷</a></p><p>tags: 线段树、离散化、枚举</p></blockquote><ul><li><p>我的解法：参照线段树的实现，结点代表区间被贴海报的编号，由于在下传懒标记时也会清空本身结点的值，因此从有结点的编号到根节点的路径上的其他结点的值全是<span class="math inline">\(0\)</span> ，<spanclass="math inline">\(0\)</span>代表着结点表示的区间由多个编号海报组成，或者是未被粘贴（这种情况说明其祖先中一定有一个有值）。显然，之后查询整个区间时，遇到非<span class="math inline">\(0\)</span>结点就可以用哈希记录，第一次遇到的 <spanclass="math inline">\(ans\)</span>++ 即可（如用map记录，直接输出mp.size()亦可）</p></li><li><p>使用线段树+逆序染色。显然，由于染色不能修改已被染色的区域，既然我需要的是最后贴上的海报，那么逆序染色即可了。成功染色一个就<span class="math inline">\(ans\)</span>++，否则说明已被后面的海报覆盖。结点之间关系如下:</p><p><spanclass="math display">\[tree[p]=tree[p*2]\&amp;\&amp;tree[p*2+1]\]</span></p><p>由于染色用 <span class="math inline">\(tree[p]=1（或true）\)</span>表示，这个式子表达的意思是，是否两个子区间均被染色，如果是，显然整个<strong>tree[p]</strong> 代表的整个区间已经染色完了。</p></li><li><p>浮水法。</p></li><li><p>珂朵莉树</p></li></ul><hr /><h2 id="蓝矿洞坍塌">[蓝]矿洞：坍塌</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4979">P4979 矿洞：坍塌 -洛谷</a></p></blockquote><details>    <summary>题目大意</summary>    对于给出的一字符串s，仅存在三种三种元素：{A,B,C}，对于此字符串，我们想要做如下两种操作：    1. 当flag = A时，给出x,y,op,修改区间[x,y]的所有元素为op。    2. 当flag = B时，给出x,y,查询区间是否"合法"   一个区间合法的标志是：[x,y]区间的元素均相同，且第x-1号元素和第y+1号元素并不相同</details>这里给出珂朵莉树的解法，实现上采用 `std::set` ，保留经典操作 `split` 和`assign` ，此时如果直接暴力查询，则能得到90分，剩下10分考虑算法优化。<p>显然，珂朵莉树适用于数据集随机的情况，但此题显然B型操作过多。我们知道当存在大量不同区间时，珂朵莉树从理想下的<span class="math inline">\(O(mloglogn)\)</span>趋近于平方级。考虑题重要的一点：元素仅存在三种。说明大量不同区间实际上是可以合并的，比如<code>assign</code>操作后可能新区间能与邻居区间合并，于是选择在<code>assign</code> 采用<code>union</code> 操作。虽然时间仍差了一步，但 <code>union</code>带来的惊喜是，显然<strong>相同值的连续区间一定能被一个结点表示</strong>，那么就可以优化查询操作（这是最重要的），即得到大于<code>x</code> 的第一个结点的前驱 <code>itl</code>，大于 <code>y</code>的第一个结点的前驱 <code>itr</code> ，那么显然<code>itl</code> 和<code>itr</code> 是一定包含 <code>l</code> 和 <code>r</code>的。于是我们知道:</p><ul><li><code>itl</code>!=<code>itr</code> ，说明 <spanclass="math inline">\([l,r]\)</span> 区间值不全相同，返回 <spanclass="math inline">\(false\)</span></li><li><code>itl-l &lt; l &amp;&amp; itr&gt;r</code> 说明 <spanclass="math inline">\(x-1\)</span> 和 <spanclass="math inline">\(y+1\)</span> 的值相同，非法，返回 <spanclass="math inline">\(false\)</span></li><li>如果结点只包含 <span class="math inline">\([l,r]\)</span> 检查 <spanclass="math inline">\(prev(itl) == next(itr)\)</span>，如果成立，非法，返回 <span class="math inline">\(false\)</span></li><li>其余返回 <span class="math inline">\(true\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">char</span> v;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">const</span> <span class="type">int</span> &amp;il,<span class="type">const</span> <span class="type">int</span> &amp;ir,<span class="type">const</span> <span class="type">char</span> &amp;iv): <span class="built_in">l</span>(il),<span class="built_in">r</span>(ir),<span class="built_in">v</span>(iv)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;o) <span class="type">const</span>&#123;<span class="keyword">return</span> l&lt;o.l;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;node&gt; odt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(<span class="number">1</span>,N<span class="number">+1</span>,<span class="string">&#x27;#&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = odt.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(x,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(it!=odt.<span class="built_in">end</span>()&amp;&amp;it-&gt;l==x) <span class="keyword">return</span> it;</span><br><span class="line">    it--;</span><br><span class="line">    <span class="type">int</span> l=it-&gt;l,r=it-&gt;r;<span class="type">char</span> v=it-&gt;v;</span><br><span class="line">    odt.<span class="built_in">erase</span>(it);</span><br><span class="line">    odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,x<span class="number">-1</span>,v));</span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(x,r,v)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> odt.<span class="built_in">upper_bound</span>(<span class="built_in">node</span>(x,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(set&lt;node&gt;::iterator a)</span></span>&#123; <span class="comment">//查看是否能合并周围结点，如果能就合并</span></span><br><span class="line">    <span class="keyword">auto</span> l = a,r = <span class="built_in">next</span>(a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prev</span>(a)-&gt;v == a-&gt;v)&#123;</span><br><span class="line">        l = <span class="built_in">prev</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">next</span>(a)-&gt;v == a-&gt;v)&#123;</span><br><span class="line">        r = <span class="built_in">next</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">next</span>(l) != r)&#123;</span><br><span class="line">        <span class="type">int</span> il = l-&gt;l,ir = <span class="built_in">prev</span>(r)-&gt;r,iv = l-&gt;v;</span><br><span class="line">        odt.<span class="built_in">erase</span>(l,r);</span><br><span class="line">        odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(il,ir,iv));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">char</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = <span class="built_in">split</span>(r<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> itl = <span class="built_in">split</span>(l);</span><br><span class="line">    odt.<span class="built_in">erase</span>(itl,itr);</span><br><span class="line">    <span class="keyword">auto</span> it = odt.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,v)).first;</span><br><span class="line">    <span class="built_in">merge</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLegal</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = <span class="built_in">prev</span>(<span class="built_in">find</span>(r)),itl=<span class="built_in">prev</span>(<span class="built_in">find</span>(l)); <span class="comment">// 左端点&lt;=r 和&lt;=l的区间 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(itr != itl) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//[l,r]区间里不止一个区间（值）</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(itl-&gt;l &lt; l &amp;&amp; itr-&gt;r &gt; r) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//两边值一样</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(itl-&gt;l == l &amp;&amp; itr-&gt;r == r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">prev</span>(itl)-&gt;v == <span class="built_in">next</span>(itr)-&gt;v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">initial</span>(N);</span><br><span class="line">    <span class="type">char</span> a[N<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l = i;</span><br><span class="line">        <span class="keyword">while</span>(a[i] == a[i<span class="number">+1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assign</span>(l,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="type">char</span> flag;</span><br><span class="line">        cin &gt;&gt; flag;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="type">char</span> op;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; op;</span><br><span class="line">            <span class="built_in">assign</span>(x,y,op);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="built_in">isLegal</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="橙图的遍历">[橙]图的遍历</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3916#ide">P3916 图的遍历 -洛谷</a></p><p>反向建边</p></blockquote><p>反向建边，那么凡是可以到达 <span class="math inline">\(p\)</span>结点的，在反向建边后都是 <span class="math inline">\(p\)</span>结点可到达的。从最大编号开始 <span class="math inline">\(dfs\)</span>遍历即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> head[N],to[N],nxt[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    nxt[++cnt] = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans[u]) <span class="keyword">return</span>;</span><br><span class="line">    ans[u] = w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> v = to[i];</span><br><span class="line">        <span class="built_in">dfs</span>(v,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">search</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="力扣">力扣</h1><h2 id="困难接雨水">[困难]接雨水</h2><blockquote><p><ahref="https://leetcode.cn/problems/trapping-rain-water/description/">42.接雨水 - 力扣（LeetCode）</a></p></blockquote><details>    <summary>题目大意</summary>    给定一组宽度为1的柱子高度，问下雨之后这一组柱子能接多少水？</details><p>三种方法</p><p>我的做法是双指针，但由于 <span class="math inline">\(i!=j\)</span>时会多余遍历剩余元素，并非双指针的最优解（虽然过了）</p><blockquote><p>可不看</p><p>设立双指针 <span class="math inline">\(i,j\)</span> ，<spanclass="math inline">\(j\)</span> 找出第一个比 <spanclass="math inline">\(i\)</span> 大的值，并结算，再让 <spanclass="math inline">\(i=j\)</span>，继续搜索。如果未找到，就记录其中最大高度的位置 <spanclass="math inline">\(maxp\)</span> ，结算，并让 <spanclass="math inline">\(i=maxp\)</span> 。显然，<spanclass="math inline">\(loop\)</span> 的条件是 <spanclass="math inline">\(i&lt;n-1\)</span></p></blockquote><p><strong>双指针</strong></p><p><strong>动态规划</strong></p><p>从左边开始扫描一边到 <span class="math inline">\(i\)</span>前的最大值，同理从右边再扫描一边，两边合起来结算即可。</p><p><strong>单调栈</strong></p><h2 id="困难执行操作后元素的最高频率-ii">[困难]执行操作后元素的最高频率II</h2><blockquote><p><ahref="https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/?envType=daily-question&amp;envId=2025-10-22">3347.执行操作后元素的最高频率 II - 力扣（LeetCode）</a></p></blockquote><details>    <summary>题目大意</summary>    <p>每个数只能被做一次这样的操作：加上一个范围为[-k,k]的一个数。对于给定的操作数numOperations，问如何使得在所有情况中，数组中的元素的最高频率最大。</p>    元素的频率，指的是它在数组中出现的次数。最高频率的元素，是数组中出现次数最多的元素。</details><p><strong>差分法</strong></p><p>显然，我们可以利用差分性质得到每个数（包含 <spanclass="math inline">\(nums[i]+c,c\in[-k,k]\)</span>）可能实现的频率。</p><p>同时，由于有操作次数的限制，如果答案对应的元素在原数组出现的话，消耗的操作次数显然是<span class="math inline">\(最大频率-原出现次数\)</span> 。因此这里用<code>cnt</code> 记录每个元素的出现次数。</p><p>具体实现如下：</p><ul><li>构造差分数组 <code>diff</code> ，所有元素初始化为 <spanclass="math inline">\(0\)</span></li><li>遍历所有元素，使 <spanclass="math inline">\(diff[nums[i]-k]\)</span> 增加 <spanclass="math inline">\(1\)</span> ，<spanclass="math inline">\(diff[nums[i]+k+1]\)</span> 减少 <spanclass="math inline">\(1\)</span></li><li>对差分数组做前缀和操作，得到每个数的可能的最大出现次数<code>diff[nums[i]]</code></li><li>对于所有的出现次数，比较 <code>numOperation+cnt[nums[i]]</code> 和<code>diif[nums[i]]</code> ，答案取最大值</li></ul><p>注意：</p><p>由于数组 <span class="math inline">\(nums\)</span>的元素范围较大，这里不再使用差分数组，而通过<code>map&lt;int,int&gt;</code> 类型构造差分序列，由于 <spanclass="math inline">\(nums[i]\)</span>存在本来就有的次数，遍历时要注意到它，因此如果其未被插入，就要插入 <spanclass="math inline">\(nums[i]\)</span> 且值为 <spanclass="math inline">\(0\)</span> 。（由于可能存在 <spanclass="math inline">\(nums[i]+c==nums[k]\)</span>，所以要判断其是否已经插入）</p><h2 id="困难计算子数组的-x-sum-ii">[困难]计算子数组的 x-sum II</h2><blockquote><p><ahref="https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-ii/description/?envType=daily-question&amp;envId=2025-11-05">3321.计算子数组的 x-sum II - 力扣（LeetCode）</a></p></blockquote><h1 id="码蹄集oj百度">码蹄集OJ(百度)</h1><h2 id="青铜房间打扫">[青铜]房间打扫</h2><blockquote><p>码蹄杯2022 MC0102房间打扫</p><p><ahref="https://www.matiji.net/exam/brushquestion/2/4009/C448715ED43BEA9D2D47CED523050945">码蹄集OJ-房间打扫</a></p><p>核心：寻找等价关系</p></blockquote><p>实际上，最多打扫干净的行数为有着相同字符串，或者说有相同元素的行数的最大值。</p><hr /><h2 id="黄金项链">[黄金]项链</h2><blockquote><p>码蹄杯2022 MC0104项链</p><p><ahref="https://www.matiji.net/exam/brushquestion/4/4009/C448715ED43BEA9D2D47CED523050945">码蹄集OJ-项链</a></p><p>核心：数学思维</p></blockquote><details>    <summary>碰巧做对的思路</summary>    每次一最小一最大排列，最后计算美观值。这个实际上是最佳序列的其中一种，它恰好实现了大值加2次，小值减两次，以及个数为奇数情况下的第n/2大个数恰好一加一减被抵消了而已。</details><p>​ 我们知道，这道题如果没有绝对值的限制，显然总和为 <spanclass="math inline">\(0\)</span> ，因为每个数都恰好地被做了一对加减法。在加了绝对值的情况下，对于美观值答案<spanclass="math inline">\(ans\)</span>，我们显然期望两次加的都是更大的，两次减的都是最小的，因此最佳期望的答案是</p><p><span class="math display">\[ans =2*|最大的n/2个数总和-最小的n/2个数总和|\]</span></p><p>​这个最佳序列是可以得到的，只要保证这两队数奇偶位置分别放置即可，即保证大值左右两旁有小值，这样大值就被加了两次。</p><p>​ 注意，当个数 <span class="math inline">\(n\)</span>为奇数时，对于第中间大数 <spanclass="math inline">\(a_{n/2}\)</span>，由于比它大的数与比它小正好匹配，即比它大的数都加了两次，比它小的数都减了两次，可怜的<span class="math inline">\(a_{n/2}\)</span>只能本身做一次加减法，因此被抵消掉了。</p><hr /><h2 id="青铜白日梦">[青铜]白日梦</h2><blockquote><p><ahref="https://www.matiji.net/exam/brushquestion/12/4009/C448715ED43BEA9D2D47CED523050945">码蹄杯2022-MC0112白日梦Ⅰ</a></p><p>核心：前缀极值的动态维护</p></blockquote><p>这道题的核心思想非常巧妙，由于我们只做一次来回兑换，显然我们想要换英镑时汇率是大的，这样我们只要在遍历前记录当前最大值并更新<span class="math inline">\(ans\)</span> 和最大值 <spanclass="math inline">\(mx\)</span> 即可。</p><hr /><h2 id="白银水往低处流">[白银]水往低处流</h2><blockquote><p>码蹄杯2022 MC0116水往低处流</p><p><ahref="https://www.matiji.net/exam/brushquestion/16/4009/C448715ED43BEA9D2D47CED523050945">码蹄集OJ-水往低处流</a></p><p>核心：寻找等价关系</p></blockquote><details>    <summary>题目大意</summary>    有一 n*n 的梯田，可往格子里浇上一桶水，同时它和比它严格低的格子会是“湿润的”，问至少需要多少桶水，使得梯田完全湿润。</details>一道非常巧妙的题，我们要记录需要多少桶水，事实上等价于有多少格子要是“湿润的”，这又等价于有多少格子的邻居没有比它高的，这样不会有水流向它，它只能用上一桶水，并为邻居供水。也可以反过来想，有多少格子可以通过邻居供水（即有邻居比它高，会有水流向它），再用 $n*n$ 减去即可。<hr /><h2 id="白银子集统计">[白银]子集统计</h2><blockquote><p>码蹄杯2022 MC0126 子集统计</p><p><ahref="https://www.matiji.net/exam/brushquestion/26/4009/C448715ED43BEA9D2D47CED523050945">码蹄集OJ-子集统计</a></p><p>核心：位运算、排列组合</p></blockquote><p>​ 有意思的思维题，<span class="math inline">\(a \&amp;c=c\)</span>，意味着凡是 <span class="math inline">\(a\)</span> 有 <spanclass="math inline">\(1\)</span> 的地方都可以随便填，而 <spanclass="math inline">\(a\)</span> 有 <spanclass="math inline">\(0\)</span> 的地方只可以填 <spanclass="math inline">\(0\)</span>（因为与操作要求同一位上两个均为 <spanclass="math inline">\(1\)</span> 才能为 <spanclass="math inline">\(1\)</span>），同理，<spanclass="math inline">\(c\&amp;b=b\)</span>为相反情况，如果 <spanclass="math inline">\(b\)</span> 有 <spanclass="math inline">\(1\)</span> 的地方只能填 <spanclass="math inline">\(0\)</span>，如果之前标记了只能填 <spanclass="math inline">\(0\)</span>，那么显然冲突，无解并退出。否则，用<span class="math inline">\(n\)</span>记录下可以随便填的位数，一位有两种状态 <spanclass="math inline">\(0\)</span> 与 <spanclass="math inline">\(1\)</span>，显然答案为 <spanclass="math inline">\(pow(2,n)\)</span>。</p><hr /><h2 id="白银函数的幂ⅱ">[白银]函数的幂Ⅱ</h2><blockquote><p>码蹄杯2022 MC0136函数的幂Ⅱ <ahref="https://www.matiji.net/exam/brushquestion/36/4009/C448715ED43BEA9D2D47CED523050945">码蹄集OJ-函数的幂Ⅱ</a></p><p>核心：找规律</p></blockquote><details>    <summary>题目大意</summary>    对于 f(a,b) 存在a=1时，f(a,b) = c*b+d, 否则 f(a,b) = f(a-1,f(a-1,b))。问对给出的a、b、c、d的最终答案的个位数。其中 a 可能高达1e6</details>显然，函数 $f(a,b)$ 所需要的计算次数是 $2^{a-1}$ 的级别，这是我们所不能承担的，但题目要求的是个位数，我们可以发现这个个位数一定是有规律的，最多有10个不同的数，但注意，可能最开始的几个数并不在循环之中。我们可以使用记忆化搜索，使用 dp\[1000000+10]\[10] 记录出现的结果，从而避免指数级的递归。当然，如若数据实在太大以至于无法存储，我们应该找出其中的规律。 <p>事实上，还可以通过迭代实现，因为是求个位数，我们知道其实 <spanclass="math inline">\(f(a,b)\)</span> 总能化成 <spanclass="math inline">\(C_ix+D_i\)</span> 的形式，由于我们只求个位数，<span class="math inline">\(C\)</span> 、<spanclass="math inline">\(D\)</span> 对其的影响也只有其个位上的数字，每次<span class="math inline">\(a\)</span> 上升 <spanclass="math inline">\(1\)</span> 都是倍增的，于是我们可以这样更新 ：</p><p><span class="math display">\[C_{i+1} = C_i*C_i \mod10\]</span></p><p><span class="math display">\[D_{i+1} = (C_i*D_i+D_i) \mod10\]</span></p><hr /><h2 id="白银快速计算">[白银]快速计算</h2><blockquote><p>码蹄杯2022 MC0152快速计算</p><p><ahref="https://www.matiji.net/exam/brushquestion/52/4009/C448715ED43BEA9D2D47CED523050945">码蹄集OJ-快速计算</a></p><p>核心：合并多项操作、预处理</p></blockquote><p>这是比较难的白银题了。要两个要处理的点，一个是所有操作可变成一个线性操作<spanclass="math inline">\(Ax+b\)</span>，这里无需赘述。但这远远不够——这些数据也开得太大了吧。对总<span class="math inline">\(q\)</span> 个还要做 <spanclass="math inline">\(p\)</span> 次操作，还与变量 <spanclass="math inline">\(x\)</span> 有关！我们发现，<spanclass="math inline">\(p\)</span> 次操作仍只需一阶 <spanclass="math inline">\(x\)</span>，本来可以化成 <spanclass="math inline">\((a^n)x +一个等比数列和\)</span>，但这样我又要搞快速幂和费马小定理，太麻烦了。但由于乘数和加数与<span class="math inline">\(x\)</span> 无关，只随 <spanclass="math inline">\(p\)</span> 变化而变化，可以算出各个 <spanclass="math inline">\(p\)</span> 时的 <spanclass="math inline">\(mul\)</span> 与 <spanclass="math inline">\(add\)</span>，但难不成我还要根据 <spanclass="math inline">\(p\)</span> 动态调整？我一看 <spanclass="math inline">\(p\)</span> 最多 <spanclass="math inline">\(1e6\)</span>，管你多大直接预处理，这样我们便得到了最终答案。</p><hr /><h2 id="黄金水渠规划">[黄金]水渠规划</h2><blockquote><p>码蹄杯2022 MC0154水渠规划</p><p><ahref="https://www.matiji.net/exam/brushquestion/54/4009/C448715ED43BEA9D2D47CED523050945">码蹄集OJ-水渠规划</a></p><p>核心：数学</p></blockquote><p>若有线段 <span class="math inline">\(AB\)</span>，和点 <spanclass="math inline">\(P\)</span>，则 <spanclass="math inline">\(P\)</span> 到线段 <spanclass="math inline">\(AB\)</span> 的最近距离为：</p><p><span class="math display">\[Dis(P, AB) =\begin{cases}|AP|, &amp; \frac{\vec{AP} \cdot \vec{AB}}{|\vec{AB}|^2} &lt; 0 \\\frac{|\vec{AP} \times \vec{AB}|}{|\vec{AB}|}, &amp; 0 \le\frac{\vec{AP} \cdot \vec{AB}}{|\vec{AB}|^2} \le 1 \\|BP|, &amp; \frac{\vec{AP} \cdot \vec{AB}}{|\vec{AB}|^2} &gt; 1\end{cases}\]</span></p><ul><li>当 <span class="math inline">\(\frac{\vec{AP} \cdot\vec{AB}}{|\vec{AB}|^2} &lt; 0\)</span>，即 <spanclass="math inline">\(P\)</span> 的垂足不在线段上，投影点在 <spanclass="math inline">\(A\)</span> 左边，则到线段的最近距离为 <spanclass="math inline">\(|AP|\)</span>。</li><li>当 <span class="math inline">\(\frac{\vec{AP} \cdot\vec{AB}}{|\vec{AB}|^2} &gt; 1\)</span>，即 <spanclass="math inline">\(P\)</span> 的垂足也不再线段上，投影点在 <spanclass="math inline">\(B\)</span> 右边，则最近距离为 <spanclass="math inline">\(|BP|\)</span>。</li><li>否则，投影点在 <span class="math inline">\(AB\)</span> 之间，则到线段的最近距离就是到直线 <span class="math inline">\(AB\)</span>的最近距离，可以通过计算得到。</li></ul><p><span class="math inline">\(\vec{AP} \times \vec{AB}\)</span>的值恰好为三角形 <span class="math inline">\(ABP\)</span>面积的两倍，除以底边 <span class="math inline">\(AB\)</span>的长度，即为高的长度。</p><hr /><h2 id="剪刀石头布">剪刀石头布</h2><blockquote><p>MC0176剪刀石头布</p><p><ahref="https://www.matiji.net/exam/brushquestion/76/4009/C448715ED43BEA9D2D47CED523050945">码蹄集OJ-剪刀石头布</a></p></blockquote><h2 id="黄金世界警察">[黄金]世界警察</h2><blockquote><p>MC0204 世界警察</p><p><ahref="https://www.matiji.net/exam/brushquestion/4/4446/16A92C42378232DEB56179D9C70DC45C">码蹄集OJ-世界警察</a></p><p>核心：双指针+动态维护最后位置</p></blockquote><p>用map或者哈希表(unordered_map)动态维护元素从0到r最后出现的位置，如果已有重复元素并且包含在区间(通过l&lt;=mp[a[i]]判断)，则立马结算(注意区间应为r-1)，并更新map，每次循环结束注意更新ans。</p><hr /><h2 id="黄金未来战争">[黄金]未来战争</h2><blockquote><p>MC0221未来战争</p><p><ahref="https://www.matiji.net/exam/brushquestion/21/4446/16A92C42378232DEB56179D9C70DC45C">码蹄集OJ-未来战争</a></p><p>核心: 合并区间|差分</p></blockquote><p>​ 利用差分性质，每次让 差分数组 <span class="math inline">\(b\)</span>中的 <span class="math inline">\(b_l\)</span>, <spanclass="math inline">\(b_{r+1}\)</span> 分别加 <spanclass="math inline">\(1\)</span> 和减 <spanclass="math inline">\(1\)</span>，使得对差分数组做前缀和后，凡是充能区间都为1，最后用 <spanclass="math inline">\(ans\)</span> 记录最长连续 <spanclass="math inline">\(1\)</span> 即可。</p><h1 id="蓝桥杯">蓝桥杯</h1><h2 id="困难选数异或">[困难]选数异或</h2><blockquote><p><a href="https://www.lanqiao.cn/problems/2081/learning/">0选数异或 -蓝桥云课</a></p><p>给定一个长度为 n 的数列 <spanclass="math inline">\(A_1,A_2,⋯,A_n\)</span> 和一个非负整数 <spanclass="math inline">\(x\)</span> , 给定 <spanclass="math inline">\(m\)</span> 次查 询, 每次询问能否从某个区间 $[l,r]$中选择两个数使得他们的异或等于 <spanclass="math inline">\(x\)</span></p></blockquote><p>核心有两点:</p><ul><li><p>a异或b = x 说明 a异或x = b</p></li><li><p>对于数组b，时刻记录最近的异或对中最远的那个编号，这个“最近”指的也是这些远端中最近的。这样对于区间的处理，只用判断<span class="math inline">\(b[r]\)</span> 是否大于 <spanclass="math inline">\(l\)</span> 即可</p></li></ul><h1 id="其他">其他</h1><h2 id="学校">学校</h2><h3 id="贪吃蛇">贪吃蛇</h3><blockquote><p>这是我们学校的题 T606586 贪吃蛇</p><p>原题应该是<strong>棋盘哈密尔顿路径问题</strong> （据AI）</p><p>由于是内部校赛的题， 链接无用，下面给出题目</p></blockquote><details>    <summary>贪吃蛇问题</summary>    在贪吃蛇游戏中，玩家能够操控一条蛇，它会不停前进，且只能向上下左右四个方向运动，现在,给你的挑战是：    给定一个n∗n (1≤n≤5000)的棋盘和蛇的起点坐标(x,y)，请判断是否存在一种方式，可以使得蛇可以不重复地走过棋盘上的所有的格子（忽略蛇的长度）。</details><p>​这是一道特判题，事实上，只要是偶数阶方阵对任意出发点一定有解，对于奇数阶方阵，出发点只有一种无解情况：abs(x-y)%2== 1。</p><p>AC代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) cout &lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(x-y)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="逃离方块-磨坊">逃离方块: 磨坊</h3><p>同上 T606553 逃离方块: 磨坊</p><details>    <summary>题目大意</summary>    <div>为了提取黑色方块，猫头鹰先生成功将劳拉传送了过来。但是，为了将机器启动，他们还需要输入密码, 机器下方有一串由n位字母构成的文本，而密码就是这段文本中最长的一段连续非回文子文本$s$的长度。请你帮乌鸦先生得到启动机器的密码。</div></details><p>​ 假定s的长度为m</p><p>​ 这道题的思路是：先看是否 <span class="math inline">\(s\)</span>为回文串，显然，如果不是的话输出 <span class="math inline">\(m\)</span>，而其实别的判断也十分简单。判断是否 <spanclass="math inline">\(s\)</span> 所有元素相同，是则返回 <spanclass="math inline">\(0\)</span> ，否则返回 <spanclass="math inline">\(m-1\)</span>，注意<strong>单字母如 <spanclass="math inline">\(a\)</span>本身也是回文串</strong>，作者当时搞错成返回 <spanclass="math inline">\(1\)</span>，吃了好多罚时qaq。</p><p>​ 之所以如此，是因为我们可以证明，当 <spanclass="math inline">\(s\)</span>为回文串并非所有元素相同时，只用左右两边仍减去一个就为非回文串。首先，显然<span class="math inline">\(s_1\)</span> 和 <spanclass="math inline">\(s_m\)</span>是相同的，如果仍减去一个还要是回文串，那么 <spanclass="math inline">\(s_1\)</span> 和 <spanclass="math inline">\(s_m-1\)</span> , <spanclass="math inline">\(s_2\)</span> 和 <spanclass="math inline">\(s_{m-2}\)</span>…<spanclass="math inline">\(s_{m/2}\)</span> 和 <spanclass="math inline">\(s_{m/2-2}\)</span> 就得相同，显然只有 <spanclass="math inline">\(s\)</span>所有元素相同才行，因为我们可以由此得到这样一条式子 <spanclass="math inline">\(s_1 = s_m = s_{m-1} = s_2 = s_{m-2} =s_3...\)</span> 如此循环往复。</p><hr /><h3 id="赛洛斯星光灯塔">赛洛斯星光灯塔</h3><blockquote><p><ahref="https://www.luogu.com.cn/problem/T606530?contestId=247104">T606530赛洛斯星光灯塔 - 洛谷</a></p></blockquote><details>    <summary>题目大意</summary>    对给定的矩阵，起初全为暗，可设置翻转点，使得翻转点上下左右</details><p>找出规律即可，事实上，每一层都是连续两个翻转点相隔4格出现，再进入内层（n-4），因此采用递归策略，有两种退出条件，<spanclass="math inline">\(n==2\)</span> 与 <spanclass="math inline">\(n==4\)</span> 当 <spanclass="math inline">\(n/2\)</span> 为奇数时，最小层为 <spanclass="math inline">\(n==2\)</span> 的情况。反之，最小层为 <spanclass="math inline">\(n==4\)</span> 的情况。同时注意到翻转点个数为 <spanclass="math inline">\(n*(n-1)\)</span> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span>+t &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span>+t &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span>+t &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">2</span>+t &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>((n/<span class="number">2</span>) &amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=n)&#123; <span class="comment">//第一排</span></span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t<span class="number">-1</span>  &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                j+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="number">5</span>;</span><br><span class="line">            j = n;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=n<span class="number">-1</span>)&#123; <span class="comment">//最后一列</span></span><br><span class="line">                cout &lt;&lt; i+t<span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                i+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = n;</span><br><span class="line">            j = n<span class="number">-3</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">3</span>)&#123; <span class="comment">//最后一排</span></span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t<span class="number">+1</span>  &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                j-=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = n<span class="number">-2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">4</span>)&#123; <span class="comment">//第一列</span></span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; i+t<span class="number">+1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                i-=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">f</span>(n<span class="number">-4</span>,t<span class="number">+2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=n<span class="number">-1</span>)&#123; <span class="comment">//第一排</span></span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t<span class="number">-1</span>  &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                j+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="number">4</span>;</span><br><span class="line">            j = n;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=n)&#123; <span class="comment">//最后一列</span></span><br><span class="line">                cout &lt;&lt; i+t<span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                i+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = n;</span><br><span class="line">            j = n<span class="number">-4</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">4</span>)&#123; <span class="comment">//最后一排</span></span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t<span class="number">+1</span>  &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                j-=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = n<span class="number">-1</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">3</span>)&#123; <span class="comment">//第一列</span></span><br><span class="line">                cout &lt;&lt; i+t<span class="number">+1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; i+t &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; j+t  &lt;&lt; endl;</span><br><span class="line">                i-=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="number">4</span>)</span><br><span class="line">            <span class="built_in">f</span>(n<span class="number">-4</span>,t<span class="number">+2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; n/<span class="number">2</span>*(n/<span class="number">2</span><span class="number">+1</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">f</span>(n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以下为可视化代码</span></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">const int N = 1e4;</span></span><br><span class="line"><span class="comment">char a[N][N];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void f(long long n,int t)&#123;</span></span><br><span class="line"><span class="comment">    if(n == 2)&#123;</span></span><br><span class="line"><span class="comment">        a[1+t][1+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">        a[1+t][2+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        if((n/2) &amp;1)&#123;</span></span><br><span class="line"><span class="comment">            int i=1,j=2;</span></span><br><span class="line"><span class="comment">            while(j&lt;=n)&#123; //第一排</span></span><br><span class="line"><span class="comment">                a[i+t][j+t-1] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                a[i+t][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                j+=4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            i = 5;</span></span><br><span class="line"><span class="comment">            j = n;</span></span><br><span class="line"><span class="comment">            while(i&lt;=n-1)&#123; //最后一列</span></span><br><span class="line"><span class="comment">                a[i+t-1][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                a[i+t][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                i+=4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            i = n;</span></span><br><span class="line"><span class="comment">            j = n-3;</span></span><br><span class="line"><span class="comment">            while(j&gt;=3)&#123; //最后一排</span></span><br><span class="line"><span class="comment">                a[i+t][j+t+1] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                a[i+t][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                j-=4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            i = n-2;</span></span><br><span class="line"><span class="comment">            j = 1;</span></span><br><span class="line"><span class="comment">            while(i&gt;=4)&#123; //第一列</span></span><br><span class="line"><span class="comment">                a[i+t][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                a[i+t+1][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                i-=4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            f(n-4,t+2);</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            int i=1,j=3;</span></span><br><span class="line"><span class="comment">            while(j&lt;=n-1)&#123; //第一排</span></span><br><span class="line"><span class="comment">                a[i+t][j+t-1] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                a[i+t][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                j+=4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            i = 4;</span></span><br><span class="line"><span class="comment">            j = n;</span></span><br><span class="line"><span class="comment">            while(i&lt;=n)&#123; //最后一列</span></span><br><span class="line"><span class="comment">                a[i+t-1][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                a[i+t][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                i+=4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            i = n;</span></span><br><span class="line"><span class="comment">            j = n-4;</span></span><br><span class="line"><span class="comment">            while(j&gt;=4)&#123; //最后一排</span></span><br><span class="line"><span class="comment">                a[i+t][j+t+1] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                a[i+t][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                j-=4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            i = n-1;</span></span><br><span class="line"><span class="comment">            j = 1;</span></span><br><span class="line"><span class="comment">            while(i&gt;=3)&#123; //第一列</span></span><br><span class="line"><span class="comment">                a[i+t+1][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                a[i+t][j+t] = &#x27;*&#x27;;</span></span><br><span class="line"><span class="comment">                i-=4;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(n&gt;4)</span></span><br><span class="line"><span class="comment">            f(n-4,t+2);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int t;</span></span><br><span class="line"><span class="comment">    cin &gt;&gt; t;</span></span><br><span class="line"><span class="comment">    while(t--)&#123;</span></span><br><span class="line"><span class="comment">        long long n;</span></span><br><span class="line"><span class="comment">        cin &gt;&gt; n;</span></span><br><span class="line"><span class="comment">        //cout &lt;&lt; n/2*(n/2+1) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="comment">                a[i][j] = &#x27;o&#x27;;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        f(n,0);</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; a[i][j] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><style>    .red{        color:red;            font-weight:600; //bold为700，normal为400        }    details {        border: 1.5px solid #ccc;             border-radius: 6px;            padding: 0.5em;    }    summary {         border-bottom: 1px solid #aaa;            cursor: pointer;            font-weight: bold;    }}</style>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数学 </tag>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>《硅谷之火》部分简述</title>
      
      <link href="/2025/05/16/%E7%A1%85%E8%B0%B7%E4%B9%8B%E7%81%AB%E7%AE%80%E8%BF%B0/"/>
      <url>/2025/05/16/%E7%A1%85%E8%B0%B7%E4%B9%8B%E7%81%AB%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="硅谷之火部分简述">《硅谷之火》部分简述</h1><style>b {  all: unset;  font-weight:bold;}</style><blockquote><p>内容太多，目前只做了第一章的简述，对此感兴趣可以看看原书《硅谷之火》</p></blockquote><p>​尽管个人计算机问世于20世纪70年代中期、巨型计算机要回溯到20世纪50年代，我们甚至能够追溯到19世纪末对未来的幻想。</p><h2 id="火种">火种</h2><blockquote><p>上帝保佑，我真希望计算能用蒸汽运行。</p><p>——查尔斯·巴贝奇</p></blockquote><p>​ 这是火种。</p><p>​诗人拜伦和雪莱注意到科学带来的变化，交流着人工生命与人工思维，雪莱夫人玛丽·雪莱由此创作了《弗兰肯斯坦》，科学怪人这一小说形象令人望而生畏。1833年，查尔斯·巴贝奇谈起利用蒸汽进行计算并真的开始实施，他认为这“分析机”将会让人们从枯燥的脑力劳动中解放出来，而拜伦女儿艾达·拜伦极力支持并提供帮助，由于她做的工作，人们视艾达为世界上第一位程序员(Ada语言的命名因此而生)。巴贝奇关于分析机的3种设计均已失败告终，他设计的差分机虽简单而显雄心，却也仍未实现。1991年，伦敦科学博物馆的一位馆长多伦·斯沃德成功用巴贝奇时代的技术、材料造出了巴贝奇的差分机。事实上，巴贝奇设计的机器是能够运行的，他梦想之所以无法实现，全是因为他无法筹集到足够的资金，这多半由于他疏离于能提供资金的人。</p><p>​如果巴贝奇成功了，也许我们能见到这样一台巨大的蒸汽计算机出现在狄更斯笔下的伦敦，但正如玛丽·雪莱所预言的那样，要想制造出会思考的机器，关键是电力。</p><p>​ 计算机将披着逻辑的嫁衣 “嫁” 给电力。</p><p>​美国逻辑学家皮尔斯将符号逻辑学带到了美国，其过程从根本上重新定义并极大丰富了布尔代数，他还发现了布尔代数可用于模拟电气开关电路，意味着电力驱动的计算机和逻辑机是可以造出来的，这并非空想。第一台电力逻辑机由本杰明·布拉克设计，可用于处理三段论形式的逻辑句的真假判断。而早在皮尔斯还在研究逻辑与电力的联系之前，赫曼·霍列瑞斯就在设计一台制表机，用于1890年美国人口普查的计算。霍列瑞斯的公司最终被一家企业合并，这家企业后来更名为国际商业机器公司（IBM）。到20世纪20年代末，IBM靠向企业售卖专用计算器盈利，而这机器还不是计算机，它们不过是被过分美化的大型计算器而已。</p><p>​克劳德·香农在其博士论文中解释如何利用电力开关电路模拟布尔逻辑。受这一论文鼓舞，IBM高管于20世纪30年代同意斥资给哈佛大学教授霍华德·艾肯以研制MarkI， Mark I是一台受巴贝奇分析机的启发而设计的基于机电式继电器的大型计算机器。1944年，MarkI 问世并受到广泛赞誉。</p><p>​ 电力驱动正在为电子驱动让路。</p><p>​爱荷华州立大学的数学和物理学教授约翰·阿塔纳索夫将电气继电器换成电子元件的可能性，在美国参加第二次世界大战前不久，在克利福德·贝里的帮助下设计出来ABC，ABC是阿塔纳索夫-贝里计算机的首字母缩写，这台设备的开关设计不再是继电器，而是真空管（抽掉了空气的一种玻璃管）。</p><p>​英国数学家阿兰·图灵曾设想这样一台机器，通过读取某一可描述任务的编码指令，并根据指令自行完成任务。这宏大的设想仅在10年之内，在另一位数学家约翰·冯·诺依曼的手中变成了一台通用计算机。是这样的：1943年，美国费城莫尔电气工程学院的约翰·莫奇利和约翰·埃克特踢出了一个关于计算机的想法，很快，它们就和美国军方开始合作研发电子数字积分计算机（ElectronicNumerical Integrator andComputer,简称ENIAC），莫奇利和埃克特吸引了不少才华横溢的数学家，其中包括约翰·冯·诺依曼，他为建造ENIAC做出了许多贡献，还为一台更加复杂的电子离散变量自动计算机（简称EDVAC）提供了基本设想。冯·诺依曼觉得，EDVAC应该能根据指令来编写程序，而这些指令本身是作为数据输入计算机的，这为存储程序计算机创建了标准。1945年5月之后，冯·诺依曼踢出将ENIAC改为EDVAC那样的可编程计算机的方法，阿黛尔·戈尔斯坦编写了能让机器更易操作的语言。</p><p>​ 之后，ENIAC ，世界上第一台全电子数字计算机，在1946年2月14日宣告诞生。ENIAC的运行速度比继电式计算机快1000倍，在第二次世界大战结束后，制造计算机立马成了一门生意，莫奇利和埃克特帮助了雷明顿打字公司转型为斯佩里通用自动计算机公司，随后好几年里，Univac成为了计算机的代名词，而没过多久，IBM从斯佩里手上抢到了行业领头羊的位置。</p><p>​20世纪60年代出现了一款新型计算机，体积更小、价格更低，人们称之为“迷你计算机”（小型机），其中值得一提的是波士顿的DEC公司和加州帕洛阿尔托的惠普公司，他们生产的就是图灵和冯诺依曼所指的通用计算机，更小巧、高效，功能也更强大。</p><p>​机械继电器被真空管取代，到1960年，真空管又被晶体管取代，晶体管是一小片惰性晶体。最初，我们发现了一些晶体既无法归为绝缘体，又无法归为导体，于是它们被称作半导体，它们可使电流只朝一个方向流动。电气工程师利用其薄片对电流进行整流，使交流电变为直流电。之后，另一种东西很快便几乎完全取代了晶体整流器，那就是李·德·福里斯特发明的三极管，它能放大通过的电流，还能利用较弱的次级电流改变从它的一极流向另一极的强电流。后来约翰·巴丁发现，晶体表面的抑制作用会干扰电流的流动，沃尔特·巴顿的实验也成功证明这一点。1947年12月23日，晶体管诞生了。</p><p>​若干个晶体管的功能可以合并到一个半导体装置中，因为将大量的晶体管即成为一种更复杂的电路，所以被称作集成电路。由于它们本身是一些轻薄的硅片，人们也称它们为晶片或芯片。之后很快产生了一个专门制造芯片的产业链，较早的有一家肖克利半导体公司，其后来派生出仙童半导体公司，而硅谷就是以此发源的。</p><p>仙童成立10年后，其离职员工几乎遍及所有的半导体公司，事实上，除了RCA公司、摩托罗拉和德州仪器公司外，大多数半导体公司都在圣克拉拉谷地，由于半导体芯片几乎都是硅片，圣克拉拉谷地很快便以“硅谷” 之名闻名于世。</p><p>​1969年初，硅谷半导体制造商英特尔公司接受了日本Busicom计算器公司的委托，一名叫马西安·霍夫的工程师在工作中提出了一个大胆的方案，一块芯片上运行的计算机，只不过相比计算机少了一些关键部件，例如存储器和IO设备，其被称作微处理器，具有可编程性。莱斯利·维达斯是英特尔芯片设计组的负责人，他请来了之前在仙童的同事费德里科·费金的协助。1971年2月，费金将可以运行的样机套件交付给Busicom公司，其中包括4004微处理器，费金成功了！4004微处理器的意义十分重要，尽管它不过是集成电路芯片的衍生，但微处理器的功能太多了，这些功能彼此之间紧密集成，以至于人们运行设备时还得学会一门简单的新语言，也就是说，4004微处理器的指令集构成了一门编程语言。霍夫在1969年设计的4004芯片是他们和英特尔公司难以预料到的未来的第一步，两年后的8008芯片则是至关重要的第二步。</p><p>可用的8008微处理器于1972年便开始生产，但于此同时，德州仪器公司也为一个叫做“单片计算机”的东西申请了专利，出现了三款微处理器鼎立的情景。由于微处理器的复杂，英特尔让一位工程师亚当·奥斯本编写使用手册，微处理器软件则请了加州太平洋丛林镇的海军研究生院教授加里·基尔代尔，基尔代尔为其编写了一门语言和CP/M（微型计算机控制程序），后来他们在个人计算机开发领域做出了巨大贡献。</p><p>​戴维·阿尔对DEC公司沮丧至极，计算机在公司高层眼中不过是要卖掉的铁，于是他像沃兹尼亚克、阿尔布莱特和许多其他人一样，走出公司，投入到革命的热潮中。在此之前，比尔·盖茨和保罗·艾伦为英特尔8008处理器编写BASIC（BASIC是一门简单而高级的编程语言，在此时的10年前常为小型计算机所用），在其中结识保罗·吉尔伯特并基于8080微处理器造出了一台机器，他们随后成立了Traf-O-Data公司，这次创业失败了，并且在TRW公司的工作项目依旧失败，后来盖茨去了哈佛大学，艾伦加入了霍尼韦尔公司。</p><p>​到1974年的圣诞节，两人将再次痴狂于计算机事业，这一次他们再也无法自拔，他们将与爱德华·罗伯茨的MIST公司共同引爆一场个人计算机的革命，这是第一台个人计算机的开始，这是一场——<b>Altair之旅</b>。</p>]]></content>
      
      
      <categories>
          
          <category> 读书屋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 计算机史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构-ST表</title>
      
      <link href="/2025/04/16/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8/"/>
      <url>/2025/04/16/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="st表">ST表</h1><blockquote><p>参考资料：<a href="https://oi-wiki.org/ds/sparse-table/">ST 表 - OIWiki</a></p></blockquote><p>ST表(Sparse Table, 稀疏表), 是用于解决可重复贡献问题的数据结构。</p><details open>    <summary>什么是可重复贡献问题?</summary>        <p><b>可重复贡献问题</b>是指对于运算 opt, 满足 $x opt x == x $ , 则对应区间的询问就是一个可重复贡献问题。例如，最大值有$\max(x,x) = x$, gcd有 $gdc(x,x)=x$,所以RMQ和区间GCD就是一个可重复贡献问题。像区间和就不具备这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿看到的。另外 $opt$ 还必须满足结合律才能使用ST表求解。</p></details><details open>    <summary>什么是RMQ?</summary>    RMQ是英文 Range Maximujm/Minimum Query的缩写,表示区间最大(最小值)。</details>## 引入<p>我们给定 <span class="math inline">\(n\)</span> 个数, 有 <spanclass="math inline">\(m\)</span> 个询问，对于每个询问，你需要回答区间<span class="math inline">\([l,r]\)</span> 中的最大值。</p><p>​ 如果考虑暴力做法。每次都对区间 <spanclass="math inline">\([l,r]\)</span>扫描一遍，求出最大值的话，由于每次查询为 <spanclass="math inline">\(O(n)\)</span> ，当 <spanclass="math inline">\(m\)</span> 个询问足够大时，时间开销会很大。</p><h2 id="st表-1">ST表</h2><p>​ ST表基于<span class="bold">倍增</span>思想，可以做到 <spanclass="math inline">\(O(n \log{n})\)</span> 预处理，O(1)回答每个询问。但是不支持修改操作。</p><blockquote><p>对于支持修改操作的问题，线段树可以做到，详见<ahref="https://blog.4fgr.xyz/2025/04/03/数据结构-线段树/">数据结构-线段树| 4FGR の Blog</a></p></blockquote><blockquote><p>我们以求区间最大值为例, 我们发现存在 <spanclass="math inline">\(\max(x,x)=x\)</span> ,显然区间最大值是符合<span class="bold">可重复贡献问题</span>的性质。我们会对区间进行预处理，而预处理区间会有重叠部分，只要这些区间的并(union)是所求的区间，最终计算出的答案就是正确的。</p></blockquote><p>​如果手动模拟一下，可以发现我们能使用至多两个预处理过的区间来覆盖询问区间，也就是说询问时的时间复杂度可以被降至<span class="math inline">\(O(1)\)</span>在处理有大量访问的题目时十分有效。</p><p>具体实现如下：</p><p>令 <span class="math inline">\(f(i,j)\)</span> 表示区间 <spanclass="math inline">\([i,i+2^j-1]\)</span> 的最大值</p><p>显然 <span class="math inline">\(f(i,0) = a_i\)</span></p><p>这样的定义是怎么来的呢？第二维就相当于倍增的时候跳了 <spanclass="math inline">\(2^i-1\)</span>步，我们可根据倍增的思路写出状态转移方程。</p><p><span class="math display">\[f(i,j) =\max(f(i,j-1),f(i+2^{j-1},j-1))\]</span></p><blockquote><p>即，对于区间 <span class="math inline">\([i,i+2^{j-1}-1]\)</span> 和<span class="math inline">\([i+2^{j-1},i+2^{j-1}-1]\)</span>的最大值，显然就是区间 <spanclass="math inline">\([i,i+2^{j}-1]\)</span> 的最大值</p></blockquote><p>以上就是预处理部分，而对于查询，可以简单实现如下。</p><p>对于每个询问 <span class="math inline">\([l,r]\)</span>,我们把它分成两部分：<span class="math inline">\([l,l+2^s-1]\)</span> 与<span class="math inline">\([r-2^s+1,r]\)</span>, 其中 <spanclass="math inline">\(s = \lfloor \log_2(r-l+1) \rfloor\)</span>。两部分的结果的最大值就是回答。</p><blockquote><p>由于 <span class="math inline">\(s\geq 0\)</span> 能保证 <spanclass="math inline">\((l+2^s-1)-(r-2^s+1)=2(2^s-1)-(r-l+1)+1 \geq2(2^s-1)-2^s+1 \geq 0\)</span></p><p>当且仅仅当 <span class="math inline">\(l=r\)</span> 时使得差值为<span class="math inline">\(0\)</span></p><p>因此保证两区间一定能完整表示区间 <spanclass="math inline">\([l,r]\)</span></p><p>显然区间右边得表示成 <span class="math inline">\(i+2^s-1\)</span>的形式，在程序中，为</p><p><spanclass="math inline">\(max(f[l][s],f[r-(1&lt;&lt;j)+1][s])\)</span></p></blockquote><h2 id="实现代码">实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> st[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">log2</span>(r-l<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(st[l][s],st[r-(<span class="number">1</span>&lt;&lt;s)<span class="number">+1</span>][s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; st[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> li = <span class="built_in">log2</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=li;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            st[i][j] = <span class="built_in">max</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">query</span>(l,r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><style>    .red{        color:red;            font-weight:600; //bold为700，normal为400        }    .lbold{            font-weight:bold;            font-size:24px; //默认16px        }        .bold{            font-weight: bold;        }    details {        border: 1px solid #ccc;            background-color: #f0f8ff; /* 浅蓝，适合白天 */            border-radius: 6px;            padding: 0.5em;            transition: background-color 0.3s ease, border-color 0.3s ease;    }    summary {         border-bottom: 1px solid #aaa;            cursor: pointer;            font-weight: bold;    }    @media (prefers-color-scheme: dark) {        details {            background-color: #1e2a38; /* 深蓝灰，护眼又有层次 */            border: 1px solid #444;        }        summary {            font-weight: bold; /*粗体*/            font-size:20px; /*比一般的大*/            border-bottom: 1px solid #666;            color: #e0e0e0;        }}</style>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> ST表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>动态规划-背包DP</title>
      
      <link href="/2025/04/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/"/>
      <url>/2025/04/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/</url>
      
        <content type="html"><![CDATA[<style>    .red{        color:red;            font-weight:600; //bold为700，normal为400        }    .lbold{            font-weight:bold;            font-size:24px; //默认16px        }        .bold{            font-weight: bold;        }    details {        border: 1px solid #ccc;            border-radius: 6px;            padding: 0.5em;            transition: background-color 0.3s ease, border-color 0.3s ease;    }    summary {         border-bottom: 1px solid #aaa;            cursor: pointer;            font-weight: bold;    }    @media (prefers-color-scheme: dark) {        details {             border: 1px solid #444;        }        summary {            border-bottom: 1px solid #666;            color: #e0e0e0;        }}</style><h1 id="背包dp">背包DP</h1><h2 id="引入">引入</h2><p>在具体讲何为背包dp前，先来看如下的例题：</p><details>    <summary>题意概要</summary>    有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_i$ 和价值 $v_i$ 两种属性，要求选若干物品放入背包使得背包中的物品的总价格</details><p>在上述例题中，由于每个物体只有两种可能的状态（取与不取），对应二进制中的0和1，这类问题便被称作<strong>0-1背包问题</strong>。</p><h2 id="0-1背包">0-1背包</h2><p>解释</p><p>例题中已知条件有第i个物品的重量<spanclass="math inline">\(w_i\)</span> ，价值<spanclass="math inline">\(v_i\)</span> 以及背包的总重量 <spanclass="math inline">\(W\)</span>。</p><p>设DP状态 <span class="math inline">\(f_{i,j}\)</span> 为在只能放前<span class="math inline">\(i\)</span> 个物品的情况下，容量为 <spanclass="math inline">\(j\)</span> 的背包所能达到的最大总价值。</p><p>考虑转移。假设当前已经处理好了前 <spanclass="math inline">\(i-1\)</span> 个物品的情况下，那么对于第 <spanclass="math inline">\(i\)</span>个物品当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为<span class="math inline">\(f_{i-1,j}\)</span>；当其放入背包时，背包的剩余容量会减小 <spanclass="math inline">\(w_i\)</span> 背包中物品的总价值会增大 <spanclass="math inline">\(v_i\)</span> ，故这种情况的最大价值为 <spanclass="math inline">\(f_{i-1,j-w_{i}}+ v_i\)</span></p><p>由此可以得出状态转移方程： <span class="math display">\[f_{i,j} = max(f_{i-1,j},f_{i-1,j-w_i}+v_i)\]</span>这里如果直接采用二维数组对状态进行记录，会出现MLE。可以考虑改用滚动数组的形式来优化。由于对<span class="math inline">\(f_i\)</span> 有影响的只有 <spanclass="math inline">\(f_{i-1}\)</span> , 可以去掉第一维，直接用 <spanclass="math inline">\(f_i\)</span> 来表示处理到当前物品时背包容量为<span class="math inline">\(i\)</span> 的最大价值，得出以下方程: <spanclass="math display">\[f_j = max(f_j,f_{j-w_i}+v_i)\]</span>务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。</p><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l= W; l&gt;=w[i];l--)&#123;</span><br><span class="line">        f[l] = <span class="built_in">max</span>(f[l],f[l-w[i]]+ v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包">完全背包</h2><p><strong>解释</strong></p><p>完全背包模型与 <span class="math inline">\(0-1\)</span> 背包类似，与<span class="math inline">\(0-1\)</span>背包的区别仅在于一个物品可以选取无限次，而非仅能选择一次。</p><p>我们可以借鉴 <span class="math inline">\(0-1\)</span>背包的思路，进行状态定义：设 <spanclass="math inline">\(f_{i,j}\)</span> 为只能选前 <spanclass="math inline">\(i\)</span> 个物品时，容量为 <spanclass="math inline">\(j\)</span> 的背包可以达到的最大价值。</p><p>需要注意的是，虽然定义与 <span class="math inline">\(0-1\)</span>背包类似，但是其状态转移方程和 <span class="math inline">\(0-1\)</span>并不相同。</p><p><strong>过程</strong></p><p>可以考虑一个朴素的做法：对于第 <span class="math inline">\(i\)</span>件物品，枚举其选了多少个来转移。这样做的时间复杂度时 <spanclass="math inline">\(O(n^3)\)</span>的。</p><p>状态转移方程如下： <span class="math display">\[f_{i,j} = \max\limits_{k=0}^{+\infty} \left(f_{i-1,j-k\times w_i} +v_i\times k\right)\]</span> 考虑做一个简单的优化。可以发现，对于 <spanclass="math inline">\(f_{i,j}\)</span> ，只要通过 <spanclass="math inline">\(f_{j,j-w_i}\)</span>转移就可以了。因此状态转移方程为： <span class="math display">\[f_{i,j} = \max(f_{i-1,j}, f_{i,j-w_i}+v_i)\]</span> 理由时当我们这样转移时，<spanclass="math inline">\(f_{i,j-w_i}\)</span> 已经由 <spanclass="math inline">\(f_{i,j}-2\times w_i\)</span> 更新过，那么 <spanclass="math inline">\(f_{i,j-w_i}\)</span> 就是充分考虑了第 <spanclass="math inline">\(i\)</span>件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。</p><h2 id="多重背包">多重背包</h2><p>在原有的0-1背包问题上，第 <span class="math inline">\(i\)</span>个物品可被选择 <span class="math inline">\(k_i\)</span> 次</p><p>最朴素的多重背包，就是化成0-1背包的形式，把每 <spanclass="math inline">\(k_i\)</span>个相同的物品当成不同的物品逐个放置，按 0-1 背包做即可。</p><p>这个方法简单，但时间、空间复杂度有一定要求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w[i];j--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k+w[i]&lt;=j &amp;&amp; k&lt;= cnt[i];k++)&#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k+w[i]]+k*v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制分组">二进制分组</h3><p>我们发现，上述情况下，相同物品会被重复计算导致计算次数增大。例如，相同物品中，只算一个物品时，会被计算<span class="math inline">\(C_n^1\)</span> 次，只算两个物品时，会被计算<span class="math inline">\(C_n^2\)</span> …… 。当然，由于用了 <spanclass="math inline">\(dp\)</span> ，这里对 <spanclass="math inline">\(k_i\)</span> 个物品会计算 <spanclass="math inline">\(k_i\times W\)</span> 次。</p><p>因此，我们需要减少分组数。</p><p>注意到，对于 <span class="math inline">\(6\)</span> 有 <spanclass="math display">\[6 = 011_2 = 11_2 +3 = 1+2+3\]</span> 对于数 <span class="math inline">\(n\)</span>，凡高位有1，都可拆出一个 <span class="math inline">\(i-1\)</span> 位全<span class="math inline">\(1\)</span> 的二进制数，即可表示为 <spanclass="math inline">\(1+2+2^2+...\)</span> ，显然 <spanclass="math inline">\(1\)</span> 之间的组合可不重复地计算 <spanclass="math inline">\([0,2^{i}-1]\)</span>的每个值，另外加上不能划分的数 <span class="math inline">\(x\)</span>，便能计算 <span class="math inline">\([x,2^{i}-1+x]\)</span>，即可计算中 <span class="math inline">\([0,n]\)</span>的所有情况。因此，只用拆分出 <span class="math inline">\(\lceil\log_2{(k+1)\rceil}\)</span> 个物品即可。</p><p><strong>实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">1</span>,p,h,k;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; h &gt;&gt; k;</span><br><span class="line">    <span class="comment">//p为单个物品重量，h为单个物品价值</span></span><br><span class="line">    <span class="keyword">while</span>(k&lt;c)&#123;</span><br><span class="line">        k-=c;</span><br><span class="line">        w[++cnt] = c*p;</span><br><span class="line">        v[cnt] = c*h;</span><br><span class="line">        c&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列优化">单调队列优化</h3><h2 id="混合背包">混合背包</h2><p>混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取<span class="math inline">\(k\)</span> 次。</p><p>实际上，合并在一起就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(循环物品种类)&#123;</span><br><span class="line">if 是0-1背包</span><br><span class="line">套用0-1背包</span><br><span class="line">else if 是完全背包</span><br><span class="line">套用完全背包</span><br><span class="line">else if 是多重背包 (如果用二进制分组就划到0-1背包)</span><br><span class="line">套用多重背包</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1833">P1833 樱花 -洛谷</a></p><h2 id="二维费用背包">二维费用背包</h2><details>    <summary><a href="https://www.luogu.com.cn/problem/P1855">P1855 榨取kkksc03</a></summary>    <p>有 $n$ 个任务需要完成，完成第 $i$ 个仍无需要花费 $t_i$ 分钟，产生 $c_i$ 元的开支。</p>    <p>现在有 $T$ 分钟时间， $W$ 元钱来处理这些任务，求最多能完成多少任务</p></details><p>这道题是很明显的 0-1背包问题，可是不同的是选一个物品会消耗两种价值（经费、时间），只需在状态中增加一维存放第二种价值即可。</p><p>这个时候就要注意，再开一维存放物品编号就不合适了，因为容易 MLE 。</p><p><strong>实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=mi;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=ti;j--)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i-mi][j-ti]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包">分组背包</h2><details>    <summary><a href="https://www.luogu.com.cn/problem/P1757">P1757 通天之分组背包</a></summary>    有 $n$ 件物品和一个大小为 $m$ 的背包，第 $i$ 个物品的价值为 $w_i$ ，体积为 $v_i% 。同时，每个物品术语一个组，同组最懂只能选择一个物品，求背包能装在物品的最大总价值。</details><p>这种题怎么想呢？其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次0-1 背包就可以了。</p><p>再说一说如何进行存储。我们可以将 <spanclass="math inline">\(t_{k,i}\)</span> 表示第 <spanclass="math inline">\(k\)</span> 组的第 <spanclass="math inline">\(i\)</span>件,像图的邻接表存就可以了。甚至你可以用链式前向星来存，不需要存 <spanclass="math inline">\(i\)</span> ，用边的编号存权重和价值即可。</p><p>作者很想搞怪，这里就用前向星的形式了，可自己想想如何如何用 <spanclass="math inline">\(t_{k,i}\)</span> 来做。</p><blockquote><p>思考：和树上背包一样，为什么我们「分组中选一个」或树上背包时「多个不同物品打包选一组」会在 <spanclass="math inline">\(j\)</span> 的循环内先遍历整个分组物品或者每 <spanclass="math inline">\(k\)</span>个一组的物品呢？（当然最外层循环是「遍历每个分组」/「遍历每个儿子」）。实际上，这就是为什么能实现在分组中选一个，和树上背包时不重复选结点的原因。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> w[N],v[N],nxt[N],to[N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; head;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head[c]) head[c] = <span class="number">-1</span>;</span><br><span class="line">    nxt[++cnt] = head[c];</span><br><span class="line">    head[c] = cnt;</span><br><span class="line">    w[cnt] = a;</span><br><span class="line">    v[cnt] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        len = <span class="built_in">max</span>(len,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=len;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=head[k];~p;p=nxt[p])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; w[p]) <span class="keyword">continue</span>;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-w[p]]+v[p]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有依赖的背包">有依赖的背包</h2><details>    <summary><a herf="https://www.luogu.com.cn/problem/P1064">「Luogu P1064」金明的预算方案</a></summary>    金明有 $n$ 元钱，想要买 $m$ 个物品，第 $i$ 件物品的价格为 $v_i$ ，重要度为 $p_i$ 。有些物品是从属于某个主件物品的附件，要买这个物品，必须购买它的主见。    目标是让所有购买物品的 $v_i \times p_i$ 之和最大。</details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>动态规划-初步</title>
      
      <link href="/2025/04/14/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5/"/>
      <url>/2025/04/14/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://oi-wiki.org/dp/basic/">动态规划基础 - OIWiki</a></p><p>目前绝大多数内容摘自OI-Wiki,个人理解重构等后续更新</p></blockquote><h1 id="动态规划初步">动态规划初步</h1><p>​ 动态规划(DynamicProgramming)，简称DP，它本身不是一种特定的算法，而是一种思想。当状态变动与之前或之后状态有关时，我们往往可以使用方程来描述这种关系。这种方程被称作状态转移方程。</p><h2 id="动态规划原理">动态规划原理</h2><p>能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。</p><h3 id="最优子结构">最优子结构</h3><p>具有最优子结构也可能是用适合贪心的方法求解。</p><p>注意要确保我们考察了最优解中用到的所有子问题</p><ol type="1"><li>证明问题最优解的第一个组成部分是做出一个选择;</li><li>对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解，你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。</li><li>给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；</li><li>证明作为构成原问题最优解的组成部分，每个子问题的解就是它本省的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题中的解用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。</li></ol><p>要保持子问题空间尽量简单，只在必要时扩展。</p><p>最优子结构的不同体现在两个方面：</p><ul><li>原问题的最优解中涉及多少个子问题。</li><li>确定最优解使用哪些子问题时，需要考察多少种选择。</li></ul><p>子问题图中每个顶点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。</p><h3 id="无后效性">无后效性</h3><p>已经求解的子问题，不会再受到后续决策的影响。</p><h3 id="子问题重叠">子问题重叠</h3><p>如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。</p><h3 id="基本思路">基本思路</h3><p>对于一个能用动态规划解决的问题，一般采用如下思路解决：</p><ol type="1"><li><p>将原问题划分为若干阶段，每个阶段对应若干个子问题，提取这些子问题的特征(称之为状态);</p></li><li><p>寻找每一个状态的可能决策，或者说是各状态间的相互转移方式(用数学的语言描述就是状态转移方程)。</p></li><li><p>按顺序求解每一个阶段的问题。</p></li></ol><p>如果用图论的思想理解，我们建立一个有向无环图，每个状态对应图上一个节点，决策对应节点键的连边。这样问题就转变为了一个再DAG上寻找最长(短)路的问题。</p><h2 id="记忆化搜索">记忆化搜索</h2><p>​记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。</p><p>​在求解动态规划的问题时，记忆化搜索与递推的代码，在形式上是高度类似的。这是由于它们使用了相同的状态表示方法和类似的状态转移。两种实现的时间复杂度是一样的，只不过是将递推的形式转换成了递归的形式。</p><p>​与递推相比，记忆化搜索因为不用明确规定访问顺序，在实现难度上有时低于递推，且能比较方便低处理边界情况。但与此同时，记忆化搜索难以使用滚动数组等优化，且由于存在递归，运行效率和低于递推。</p><h3 id="写记忆化搜索的方法">写记忆化搜索的方法：</h3><p><strong>方法一</strong></p><ol type="1"><li>把这道题的 <span class="math inline">\(dp\)</span>状态和方程写出来</li><li>根据它们写出 <span class="math inline">\(dfs\)</span> 函数</li><li>添加记忆化数组</li></ol><p><strong>方法二</strong></p><ol type="1"><li>写出这道题的暴力搜索程序(最好是 <spanclass="math inline">\(dfs\)</span>)</li><li>将这个 <span class="math inline">\(dfs\)</span>改成「无需外部变量」的 <span class="math inline">\(dfs\)</span></li><li>添加记忆化数组</li></ol><h2 id="最长公共子序列">最长公共子序列</h2><details open>    <summary>最长公共子序列问题</summary>      <div>    给定一个长度为 n 的序列 A 和一个长度为 m 的序列 B（n, m ≤ 5000），求出一个最长的序列，使得该序列既是 A 的子序列，也是B的子序列。  </div></details><p>设 <span class="math inline">\(f(i,j)\)</span> 表示只考虑 <spanclass="math inline">\(A\)</span> 的前 <spanclass="math inline">\(i\)</span> 个元素, <spanclass="math inline">\(B\)</span> 的前 <spanclass="math inline">\(j\)</span>个元素时的最长公共子序列的长度，求这时的最长公共子序列的长度就是子问题，<span class="math inline">\(f(i,j)\)</span> 就是我们所说的状态， 则<spanclass="math inline">\(f(n,m)\)</span>是最总要达到的状态，即所求结果。</p><p>对于每个<span class="math inline">\(f(i,j)\)</span> 存在三种决策:如果<span class="math inline">\(A_i=B_j\)</span>,就可将它接到公共子序列的末尾；另外两种决策分别是跳过 <spanclass="math inline">\(A_i\)</span> 或者 <spanclass="math inline">\(B_j\)</span> 。状态转移方程如下： <spanclass="math display">\[f(i,j) =\begin{cases}f(i-1,j-1)+1, &amp;A_i = B_j\\\max(f(i-1,j),f(i,j-1)), &amp;A_i \neq B_j\end{cases}\]</span> 该做法的实践复杂度为 <spanclass="math inline">\(O(nm)\)</span></p><p>另外，本题存在<span class="math inline">\(O(\frac{nm}{w})\)</span>的算法。有兴趣的同学可以自行探索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN],b[MAXM],<span class="built_in">f</span>(MAXM)[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长不下降子序列">最长不下降子序列</h3><details open>    <summary>最长不下降子序列</summary>    <p>给定一个长度为n的序列A(n<=5000), 求出一个最长的A的子序列，满足该子序列的后一个元素不小于前一个元素</p></details><p><strong>算法一</strong></p><p>设 <span class="math inline">\(f(i)\)</span> 表示以 $ A_{i} $为结尾的最长不下降子序列的长度，则所求为 $ max_{1\leq{j}\leq{i},A_j\leq{A_i}}(f(j)+1) $</p><p>容易发现该算法的时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN],d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        d[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt;= a[i])&#123;</span><br><span class="line">                d[i] = <span class="built_in">max</span>(d[i],d[j]<span class="number">+1</span>);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法二</strong></p><p>当 <span class="math inline">\(n\)</span> 的范围扩大到 <spanclass="math inline">\(n\leq10^5\)</span> 时， 第一种做法就不够快了,下面给出了一个 <span class="math inline">\(O(n\log n)\)</span>的做法。</p><p>回顾一下之前的状态: <span class="math inline">\((i,j)\)</span>。</p><p>但这次, 我们不是要按照相同的 <span class="math inline">\(i\)</span>处理状态，而是直接判断合法的 <span class="math inline">\((i,j)\)</span>。</p><p>再看一下之前的转移: <spanclass="math inline">\({(j,l-1)}\rightarrow{(i,j)}\)</span>,就可以判断某个 <span class="math inline">\((i,j)\)</span>是否合法。</p><p>初始时 <span class="math inline">\((1,1)\)</span> 肯定合法。</p><p>那么，只需要找到一个 <span class="math inline">\(l\)</span>最大合法的 <span class="math inline">\((i,j)\)</span>，就可以得到最终最长不下降子序列的长度了。</p><p>那么，根据上面的方法，我们就需要维护一个可能的转移列表，并逐个处理转移。</p><p>所以可以定义<span class="math inline">\(a_1···a_n\)</span>为原始序列，<span class="math inline">\(d_i\)</span>为所有长度为i的不下降序列的末尾元素的最小值，<spanclass="math inline">\(len\)</span> 为子序列的长度。</p><p>初始化：<span class="math inline">\(d_1 = a_1\)</span> <spanclass="math inline">\(len=1\)</span> 。</p><p>现在我们已知最长的不下降子序列长度为1，那么我们让 <spanclass="math inline">\(i\)</span> 从<spanclass="math inline">\(2\)</span> 到 <spanclass="math inline">\(n\)</span> 循环，依次求出前 <spanclass="math inline">\(i\)</span>个元素的最长不下降子序列的长度，循环的时候我们只需要维护好 <spanclass="math inline">\(d\)</span> 这个数组还有 <spanclass="math inline">\(len\)</span> 就可以了，关键在于如何维护。</p><p>考虑进来一个元素 <span class="math inline">\(a_i\)</span> :</p><ol type="1"><li>元素大于等于 <span class="math inline">\(d_{len}\)</span>，直接将该元素插入到 <span class="math inline">\(d\)</span>序列的末尾。</li><li>元素小于 <span class="math inline">\(d_{len}\)</span>，找到第一个大于它的元素, 用 <span class="math inline">\(a_i\)</span>替换它。</li></ol><p>为什么:</p><ul><li><p>对于步骤1：</p><p>由于我们是从前往后扫，所以说元素大于等于 <spanclass="math inline">\(d_{len}\)</span>时一定会有一个不下降子序列使得这个不下降子序列的末项后面可以再接这个元素。</p></li><li><p>对于步骤2：</p><p>同步骤1，如果插在 <span class="math inline">\(d\)</span>的末尾，那么由于前面的元素大于要插入的元素，所以不符合 <spanclass="math inline">\(d\)</span>的定义，因此必须先找到第一个大于它的元素，再用 <spanclass="math inline">\(a_i\)</span> 替换。</p></li></ul><p>步骤2如果用暴力查找，则时间复杂度仍然是 <spanclass="math inline">\(O(n^2)\)</span> 的。但是根据 <spanclass="math inline">\(d\)</span> 数组的定义,d一定是单调不减的，因此可以采用二分查找将时间复杂度降至 <spanclass="math inline">\(O(n\log n)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">memset</span>(dp,ox1f,<span class="keyword">sizeof</span> dp); <span class="comment">//初始化dp很大</span></span><br><span class="line">mx = dp[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">    <span class="comment">//寻找第一个大于a[i]的元素的位置</span></span><br><span class="line">    *std::<span class="built_in">upper_bound</span>(dp, dp+n,a[i]) = a[i];</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(dp[ans]!=mx) ++ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每次寻找第一个大于a[i]元素的位置，并将其赋值为a[i]，即便顺序是不对的，但实际上保留了最长不下降子序列的最大长度 我们假设我们更新了a[i](占据了之前a[0···i-1]的某一个位置)，当我们判断a[i+1]时，它如果刚好小于a[i]的后面的某个元素，那么就插在那个元素的位置，与a[i+1]同理，如果它大于d[len-1],就说明其延长了len，结果是无视之前a[i]插入的影响的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><style>    .red{        color:red;            font-weight:600; //bold为700，normal为400        }    .lbold{            font-weight:bold;            font-size:24px; //默认16px        }        .bold{            font-weight: bold;        }    details {        border: 1px solid #ccc;            background-color: #f0f8ff; /* 浅蓝，适合白天 */            border-radius: 6px;            padding: 0.5em;            transition: background-color 0.3s ease, border-color 0.3s ease;    }    summary {         border-bottom: 1px solid #aaa;            cursor: pointer;            font-weight: bold;    }}</style>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构-线段树</title>
      
      <link href="/2025/04/03/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2025/04/03/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树">线段树</h1><blockquote><p>参考: <a href="https://oi-wiki.org/ds/seg/">线段树 - OI Wiki</a></p></blockquote><p>​线段树是一种二叉搜索树、平衡二叉树，对于区间的修改、维护和查询时间复杂度优化为log级别。对区间不断做平分区间，直到划分到只有一个或多个数据的区间，可表示区间的和或者最小最大值。在进行更新区间操作时，通过小区间更新大区间。</p><p>​对于下面的内容，我们主要针对于区间加法的线段树(即其节点表示区间之和)。</p><p>​ <strong>局限性：</strong></p><ul><li><p>问题需满足区间加法：对于[L,R]的区间，它的答案可以由[L,M]和[M+1,R]的答案合并求出。</p></li><li><p>不满足区间的众数、区间最长连续问题、最长不下降问题等。</p></li></ul><h2 id="建树">建树</h2><p>当我们拥有数组 <span class="math inline">\(a\)</span>并且用来区间求和之类的问题时，我们可以这样做：</p><p>​ 以堆的方式实现存储(树形数组)，将元素放至树的最下面一层。</p><p>由于我们使用树形数组，为了存储下数组 <spanclass="math inline">\(a\)</span>, 数组 <spanclass="math inline">\(tree\)</span> 的长度应当为 <spanclass="math inline">\(a\)</span>的四倍，并且初始节点位置为1。同时，当前区间[s,t]只有一个元素时(即s==t)，意味着当前节点为叶子节点，就要让当前节点<span class="math inline">\(tree[p] =a[s]\)</span>。对于其它的情况，我们求得当前区间的中间数来区分左子树和右子树，并使用递归创建左子树和右子树，最后将左孩子和右孩子节点的值之和赋值给当前节点。</p><p>​ 显然，初始建树时使用build(1,n,1)</p><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> tree[<span class="number">4</span>*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t)&#123;</span><br><span class="line">        tree[p] = a[s];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s+((t-s)&gt;&gt;<span class="number">1</span>); <span class="comment">//使用位运算更快</span></span><br><span class="line">        <span class="built_in">build</span>(s,m,p*<span class="number">2</span>); <span class="comment">//建立左子树</span></span><br><span class="line">        <span class="built_in">build</span>(s,m,p*<span class="number">2</span><span class="number">+1</span>); <span class="comment">//建立右子树</span></span><br><span class="line">        tree[p] = tree[p*<span class="number">2</span>]+tree[p*<span class="number">2</span><span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间修改">区间修改</h2><p>我们假设目标区间为[l,r],当前区间为[s,t], 对目标区间的所有元素均加上值<span class="math inline">\(k\)</span></p><p>​由于是对目标区间的修改，很可能我们不用遍历完叶子节点，在当前区间刚好覆盖目标区间，或者目标区间由多个节点组成时，由于所有区间都是加上一个相同的值<span class="math inline">\(k\)</span>，我们可以修改结果为</p><center>$$当前值 tree[p] + 当前区间的个数(t-s+1)*k$$</center><p>​ 修改完节点后记住要更新之前节点。</p><p>​ 出于效率的需要，我们会用到懒惰标记 <spanclass="math inline">\(lazy\)</span>将此区间标记，表示这个区间的值已经更新，但它的子区间却没有更新，更新的信息就是标记里存的值。</p><p>区间修改步骤:</p><ul><li>如果要修改的区间完全覆盖当前区间，直接更新这个区间，加上 <spanclass="math inline">\(lazy\)</span> 标记（表示区间内元素加k）</li><li>如果没有完全覆盖，且当前区间有 <spanclass="math inline">\(lazy\)</span> 标记，先下传 <spanclass="math inline">\(lazy\)</span> 标记到子区间，再清除当前区间的<spanclass="math inline">\(lazy\)</span>标记</li><li>如果修改区间和左儿子有交集，搜索左儿子(避免死递归)</li><li>如果修改区间和右儿子有交集，搜索右儿子</li><li>最后将当前区间的值更新, 即节点的值为子节点值之和</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lazy[<span class="number">4</span>*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=s &amp;&amp; t&lt;=r)&#123;</span><br><span class="line">        tree[p] += (t-s<span class="number">+1</span>)*k;</span><br><span class="line">        lazy[p] += k;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//检查是否要下传lazy标记</span></span><br><span class="line">        <span class="keyword">if</span>(lazy[p])&#123;  <span class="comment">//注意是否p*2超过数组长度，可以用s!=t的条件限制</span></span><br><span class="line">            tree[p*<span class="number">2</span>] += (m-s<span class="number">+1</span>)*lazy[p];</span><br><span class="line">            tree[p*<span class="number">2</span><span class="number">+1</span>] += (t-m)*lazy[p];</span><br><span class="line">            lazy[p*<span class="number">2</span>] += lazy[p];</span><br><span class="line">            lazy[p*<span class="number">2</span><span class="number">+1</span>] += lazy[p];</span><br><span class="line">            lazy[p] = <span class="number">0</span>; <span class="comment">//清空标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=m) <span class="built_in">update</span>(l,r,s,m,<span class="number">1</span>,p*<span class="number">2</span>); <span class="comment">//左孩子区间与目标区间有交集</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;m) <span class="built_in">update</span>(l,r,m<span class="number">+1</span>,t,p*<span class="number">2</span><span class="number">+1</span>); <span class="comment">//右孩子区间与目标区间右交集</span></span><br><span class="line">        tree[p] = tree[p*<span class="number">2</span>] + tree[p*<span class="number">2</span><span class="number">+1</span>]; <span class="comment">//更新当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间查询">区间查询</h2><p>我们想要得到 <span class="math inline">\([l,r]\)</span>的区间和，和区间修改同理，在当前区间 <spanclass="math inline">\([s,t]\)</span>被覆盖时，就返回对应值，否则就搜索当前节点的左孩子和有孩子(注意到，只有对应区间与目标区间有交集时才搜索)，注意存在懒惰标记时需要下传。</p><p>步骤如下:</p><ul><li>如果要查询的区间完全覆盖当前区间，直接返回当前节点的值</li><li>如果没有被完全包含当前区间，下传 <spanclass="math inline">\(lazy\)</span> 标记</li><li>如果查询区间和左儿子有交集，搜索左儿子</li><li>如果查询区间和右儿子有交集，搜索右儿子</li><li>最后合并相关数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=s &amp;&amp; r&lt;=t)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[p];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s + ((t-s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//检查是否要下传lazy标记</span></span><br><span class="line">        <span class="keyword">if</span>(lazy[p])&#123;  <span class="comment">//注意是否p*2超过数组长度，可以用s!=t的条件限制</span></span><br><span class="line">            tree[p*<span class="number">2</span>] += (m-s<span class="number">+1</span>)*lazy[p];</span><br><span class="line">            tree[p*<span class="number">2</span><span class="number">+1</span>] += (t-m)*lazy[p];</span><br><span class="line">            lazy[p*<span class="number">2</span>] += lazy[p];</span><br><span class="line">            lazy[p*<span class="number">2</span><span class="number">+1</span>] += lazy[p];</span><br><span class="line">            lazy[p] = <span class="number">0</span>; <span class="comment">//清空标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=m) sum=<span class="built_in">getsum</span>(l,r,s,m,p*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;m) sum+=<span class="built_in">getsum</span>(l,r,s,m<span class="number">+1</span>,p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线段树区间加法和区间求和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ll N = <span class="number">1000000</span>;</span><br><span class="line">ll a[N];</span><br><span class="line">ll tr[<span class="number">4</span>*N];</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">lazy</span><span class="params">(<span class="number">4</span>*N,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对区间[s,t]建树，p为当前节点编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll s,ll t,ll p)</span></span>&#123; <span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">if</span>(s == t)&#123;</span><br><span class="line">        tr[p] = a[s];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll m = s + ((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(s,m,p*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(m<span class="number">+1</span>,t,p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">        tr[p] = tr[p*<span class="number">2</span>] + tr[p*<span class="number">2</span><span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新区间[l,r]，[s,t]为当前节点区间，p为当前节点编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll c, ll s,ll t,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123;</span><br><span class="line">        tr[p] += c*(t-s<span class="number">+1</span>);</span><br><span class="line">        lazy[p] += c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ll m = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lazy[p])&#123;</span><br><span class="line">            tr[p*<span class="number">2</span>] += lazy[p]*((m-s<span class="number">+1</span>));</span><br><span class="line">            tr[p*<span class="number">2</span><span class="number">+1</span>] += lazy[p]*((t-m));</span><br><span class="line">            lazy[p*<span class="number">2</span>] += lazy[p];</span><br><span class="line">            lazy[p*<span class="number">2</span><span class="number">+1</span>] += lazy[p];</span><br><span class="line">            lazy[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(l &lt;= m) <span class="built_in">update</span>(l,r,c,s,m,p*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; m) <span class="built_in">update</span>(l,r,c,m<span class="number">+1</span>,t,p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">        tr[p] = tr[p*<span class="number">2</span>] + tr[p*<span class="number">2</span><span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间求和</span></span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll l,ll r,ll s,ll t,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[p];</span><br><span class="line">    &#125;</span><br><span class="line">    ll m = s + ((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lazy[p])&#123;</span><br><span class="line">        tr[p*<span class="number">2</span>] += lazy[p]*((m-s<span class="number">+1</span>));</span><br><span class="line">        tr[p*<span class="number">2</span><span class="number">+1</span>] += lazy[p]*((t-m));</span><br><span class="line">        lazy[p*<span class="number">2</span>] += lazy[p];</span><br><span class="line">        lazy[p*<span class="number">2</span><span class="number">+1</span>] += lazy[p];</span><br><span class="line">        lazy[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= m) sum = <span class="built_in">getsum</span>(l,r,s,m,p*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; m) sum += <span class="built_in">getsum</span>(l,r,m<span class="number">+1</span>,t,p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt;  n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        ll op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="comment">//1表示区间加法，2表示区间求和</span></span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            ll x,y,k;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">update</span>(x,y,k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            ll x,y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">getsum</span>(x,y,<span class="number">1</span>,n,<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例">实例</h2><p>[P3870 <a href="https://www.luogu.com.cn/problem/P3870">TJOI2009]开关 - 洛谷</a></p><p>对于这道题，我们知道:</p><ul><li>区间修改不需要参数k，我们需要做的仅仅是将状态逆转,因此除了修改区间、当前区间、当前位置外，就不再需要别的参数</li><li>当灯开为1，灯关为0时，区间查询(区间求和)的结果就是答案。由于初始时，灯全部是关闭的，那么执行build函数时,只需要让<span class="math inline">\(tree[p]=1\)</span>即可</li></ul><p>​ 同时，我们很容易发现对于区间 <spanclass="math inline">\([s,t]\)</span>而言，区间灯开着的个数和灯关着的个数相加为 <spanclass="math inline">\(t-s+1\)</span>，于是乎，对于第一种操作“逆转灯泡“而言，我们只需要执行<span class="math inline">\(tree[p] = (t-s+1)-tree[p]\)</span>即可。同理可得下传懒惰标记时的处理方法。</p><p>​ 另一种不需要数学的解法是，我们同时存储<spanclass="math inline">\(tree[p]\)</span>逆转后的值，记为<spanclass="math inline">\(constract\)</span>,在build时令其为1，在更新区间和下传标记时使用swap函数交换两种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*伪代码,[l,r]为修改区间,[s,t]为当前区间,p为当前位置*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(l,r,s,t,p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=s&amp;&amp;t&lt;=r)&#123;</span><br><span class="line">tree[p] = (t-s<span class="number">+1</span>)-tree[p];  <span class="comment">//或者 swap(tree[p],constract[p]);</span></span><br><span class="line">        <span class="comment">/*这里lazy[p]该如何操作呢?*/</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> m = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lazy[p])&#123;</span><br><span class="line">            tree[p*<span class="number">2</span>] = (m-s<span class="number">+1</span>) - tree[p*<span class="number">2</span>];  <span class="comment">//swap(tree[p*2],constract[p*2])</span></span><br><span class="line">            tree[p*<span class="number">2</span><span class="number">+1</span>] = (t-m) - tree[p*<span class="number">2</span><span class="number">+1</span>]; <span class="comment">//swap(tree[p*2+1],constract[p*2+1]);</span></span><br><span class="line">            <span class="comment">/*lazy的子节点该如何更新呢？*/</span></span><br><span class="line">            lazy[p] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 实际上，这道题的最关键点在于对懒惰标记<spanclass="math inline">\(lazy\)</span>的处理。</p><p>​ 我们很容易想到，由于灯泡只有两种状态，那么懒惰标记应该可以用 <spanclass="math inline">\(true\)</span> 和 <spanclass="math inline">\(false\)</span> 表示，<spanclass="math inline">\(true\)</span>表示该区间已逆转，当搜索当该区间时下传区间。当然，<spanclass="math inline">\(false\)</span>表示该区间未被逆转。</p><p>​这是对的,但是在实际操作中我们也许会发现这样的错误：在更新区间的最后标记<spanclass="math inline">\(lazy[p]\)</span> 为 <spanclass="math inline">\(true\)</span> ;在下传 <spanclass="math inline">\(lazy[p]\)</span>时，令其孩子节点的 <spanclass="math inline">\(lazy\)</span> 值为<spanclass="math inline">\(true\)</span>或者说 <spanclass="math inline">\(lazy[p]\)</span>。</p><p>​ 实际上，当我们重复更新相同区间时, 之前已经为 <spanclass="math inline">\(true\)</span> 的 <spanclass="math inline">\(lazy\)</span> 会被再次被赋值为 <spanclass="math inline">\(true\)</span>, 但可能<spanclass="math inline">\(tree[p]\)</span>的值已经恢复原样了。同理，当我们下传懒惰标记时,很可能其孩子节点已经为 <span class="math inline">\(true\)</span>,从而造成了下传的混乱。我们很容易使用if条件解决，但为了方便起见，我们用0和1表示懒惰标记，并用异或操作^进行处理。</p><p>​ <strong>解决代码如下:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> constract[<span class="number">4</span>*N];</span><br><span class="line"><span class="type">int</span> tree[<span class="number">4</span>*N]; <span class="comment">//线段树</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lazy</span><span class="params">(<span class="number">4</span>*N,<span class="number">0</span>)</span></span>; <span class="comment">//懒标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树的建立</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t)&#123;</span><br><span class="line">        tree[p] = <span class="number">0</span>;  <span class="comment">// 初始灯泡关闭</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s+((t-s)&gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(s, m, p*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(m<span class="number">+1</span>, t, p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">        tree[p] = tree[p*<span class="number">2</span>] + tree[p*<span class="number">2</span><span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间修改,目标区间[l,r],[s,t]为当前区间，将目标区间的值逆转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s, <span class="type">int</span> t,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=s &amp;&amp; t&lt;=r)&#123;</span><br><span class="line">        tree[p] = (t-s<span class="number">+1</span>)-tree[p]; <span class="comment">//逆转灯泡</span></span><br><span class="line">        lazy[p]^=<span class="number">1</span>;  <span class="comment">//逆转状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lazy[p])&#123; <span class="comment">//将懒标记下传</span></span><br><span class="line">            tree[<span class="number">2</span>*p] = (m-s<span class="number">+1</span>) - tree[p*<span class="number">2</span>];</span><br><span class="line">            tree[<span class="number">2</span>*p<span class="number">+1</span>] = (t-m) - tree[p*<span class="number">2</span><span class="number">+1</span>];</span><br><span class="line">            lazy[p*<span class="number">2</span>] ^= lazy[p];</span><br><span class="line">            lazy[p*<span class="number">2</span><span class="number">+1</span>] ^= lazy[p];</span><br><span class="line">            lazy[p] = <span class="number">0</span>; <span class="comment">//将标记清空</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l&lt;=m) <span class="built_in">modify</span>(l,r,s,m,p*<span class="number">2</span>); <span class="comment">//部分元素被包含在左孩子，搜索左子树</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;m)<span class="built_in">modify</span>(l,r,m<span class="number">+1</span>,t,p*<span class="number">2</span><span class="number">+1</span>); <span class="comment">//部分元素被包含在右孩子，搜索右子树</span></span><br><span class="line">        tree[p] = tree[p*<span class="number">2</span>] + tree[p*<span class="number">2</span><span class="number">+1</span>];  <span class="comment">//修改后,记得更新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询区间[l,r]的总和，即区间中亮着的灯泡数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r,<span class="type">int</span> s, <span class="type">int</span> t,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=s &amp;&amp; t&lt;=r)&#123;</span><br><span class="line">        res = tree[p];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lazy[p])&#123; <span class="comment">//将懒标记下传</span></span><br><span class="line">            tree[<span class="number">2</span>*p] = (m-s<span class="number">+1</span>) - tree[p*<span class="number">2</span>];</span><br><span class="line">            tree[<span class="number">2</span>*p<span class="number">+1</span>] = (t-m) - tree[p*<span class="number">2</span><span class="number">+1</span>];</span><br><span class="line">            lazy[p*<span class="number">2</span>] ^= lazy[p];</span><br><span class="line">            lazy[p*<span class="number">2</span><span class="number">+1</span>] ^= lazy[p];</span><br><span class="line">            lazy[p] = <span class="number">0</span>; <span class="comment">//将标记清空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=m) res += <span class="built_in">getsum</span>(l,r,s,m,p*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;m)res += <span class="built_in">getsum</span>(l,r,m<span class="number">+1</span>,t,p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//建立线段树</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;m;c++)&#123;</span><br><span class="line">        <span class="type">int</span> op,a,b;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">modify</span>(a,b,<span class="number">1</span>,n,<span class="number">1</span>); <span class="comment">//逆转灯泡状态</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">getsum</span>(a,b,<span class="number">1</span>,n,<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//输出结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态开点线段树">动态开点线段树</h2><p>​ 核心：<span class="bold">结点只有被需要时才创建</span></p><p>​前面的线段树都是以树形数组或者说堆式存储的方式实现的，这就导致我们需要花费<span class="math inline">\(4n\)</span>大小的空间开销。为了节省空间，我们可以不一次性建好数，而是在最初建立一个根节点代表整个区间，只有当我们需要访问某个子区间并且这个子区间未被建立时，才建立代表这个区间的子结点。这样我们不再使用<span class="math inline">\(2p\)</span> 和 <spanclass="math inline">\(2p+1\)</span> 代表p结点的儿子，而是使用 <spanclass="math inline">\(ls\)</span> 和 <spanclass="math inline">\(rs\)</span> 数组记录儿子的编号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,cnt,root;</span><br><span class="line"><span class="type">int</span> sum[n*<span class="number">2</span>],ls[n*<span class="number">2</span>],rs[n*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Q:</span></span><br><span class="line"><span class="comment">为什么不同于之前，p要被引用传参</span></span><br><span class="line"><span class="comment">A:</span></span><br><span class="line"><span class="comment">因为这里的p实际上是被ls或rs中的元素赋值的，</span></span><br><span class="line"><span class="comment">引用传参便能修改数组中的值。</span></span><br><span class="line"><span class="comment">当我们需要创建结点时，一定要将结点p的编号</span></span><br><span class="line"><span class="comment">传送到对应的数组中，防止查询时p为空</span></span><br><span class="line"><span class="comment">同时注意，p为空可能存在于线段树的创建中，仍未遍历到x结点</span></span><br><span class="line"><span class="comment">不应当返回，而应该继续遍历至对应结点x创建完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> x,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123; <span class="comment">//结点为空(由于ls和rs被初始化为0,如果没有被赋值则为空结点(最小结点编号为根节点1))</span></span><br><span class="line">        p = ++cnt; <span class="comment">//创建新结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">        sum[p]+=f;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> m = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=m) <span class="built_in">update</span>(ls[p],s,m,x,f);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs[p],m<span class="number">+1</span>,t,x,f);</span><br><span class="line">    </span><br><span class="line">    sum[p] = sm[ls[p]] + sm[rs[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//结点为空</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=s &amp;&amp; t&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[p];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s+((t-s)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=m) ans+=<span class="built_in">query</span>(ls[p],s,m,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;m) ans+= <span class="built_in">query</span>(rs[p],m<span class="number">+1</span>,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树合并与分裂">线段树合并与分裂</h2><p>线段树的合并与分裂常见于权值线段树可维护重集的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树形数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数学-快速幂</title>
      
      <link href="/2025/03/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2025/03/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%AD%A6/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂">快速幂</h1><blockquote><p>快速幂，即快速取幂的技巧。</p><p>对于在取幂过程中，需要不断取模的过程中（例如费马小定理求模逆元）时，单纯的pow函数已经不再满足我们的需要。我们需要明白pow函数的原理，以方便我们“魔改”pow函数。</p></blockquote><h2 id="定义">定义</h2><p>快速幂，二进制取幂（Binary Exponentiation),是一个在 <spanclass="math inline">\(O(logn)\)</span> 的时间计算 <spanclass="math inline">\(a^n\)</span> 的小技巧。</p><h2 id="实现">实现</h2><h3 id="递归形式">递归形式</h3><p>按幂的定义而言，<span class="math inline">\(a^n\)</span> 等于 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(a\)</span>相乘，如果我们按照这样的定义实现算法的话，当 <spanclass="math inline">\(n\)</span> 足够大时，资源的开销就很大了。</p><p>根据指数乘法，<spanclass="math inline">\(a^{b+c}=a^{b}+a^{c}\)</span>, 当 <spanclass="math inline">\(n\)</span> 为偶数时, <spanclass="math inline">\(a^{n}=a^{\frac{n}{2}}·a^{\frac{n}{2}}\)</span>,对于 <span class="math inline">\(n\)</span> 为奇数的情况,无非是在此基础上再乘以 <span class="math inline">\(a\)</span>罢了。因此，我们很容易就能得到实现快速幂的递归形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">pow</span>(a, b/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> res * res * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代形式">迭代形式</h3><p>​显然，尽管二者理论复杂度差不多，但由于递归会花费一定的开销，因此在实践中迭代形式是更快的。</p><p>​在二进制中，除以2的操作是等同于右移1位的操作的，同时，同时我们可以将指数转化为二进制，例如<spanclass="math inline">\(a^{5}=a^{101}\)</span>，我们每次取出其中1的部分，即乘上对应的<span class="math inline">\(a^{100...}\)</span> 的部分，并且每次更新<span class="math inline">\(a\)</span> ，即在每次循环中让a自乘本身，使得<span class="math inline">\(a^{100...}\)</span>其指数长度增1，显然循环的次数由对应 <spanclass="math inline">\(n\)</span>的二进制数长度所决定，因此显然时间复杂度应该是 <spanclass="math inline">\(O(logn)\)</span> 级别的。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构-并查集</title>
      
      <link href="/2025/03/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2025/03/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集">并查集</h1><blockquote><p>参考资料:<a href="https://oi-wiki.org/ds/dsu/">并查集 - OIWiki</a></p></blockquote><h2 id="基本概念">基本概念</h2><p>并查集是一种管理元素所属的数据结构,实现为一个森林，每颗树表示一个集合,树中的节点表示对应集合的元素。</p><p>显然，并查集支持两种操作:</p><ul><li>合并(union): 合并两个元素各自所属的集合</li><li>查询(find): 查询某个元素所属的集合</li></ul><h2 id="初始化">初始化</h2><p>初始时，每个元素都位于一个单独的集合表示为一棵只有根节点的树。方便起见，我们将根节点的父亲设为自己。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dsu</span>&#123;</span><br><span class="line">    vector&lt;<span class="type">size_t</span>&gt; pa;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">dsu</span><span class="params">(<span class="type">size_t</span> size)</span>:pa(size)&#123;</span><span class="built_in">iota</span>(pa.<span class="built_in">begin</span>(),pa.<span class="built_in">end</span>(),<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询">查询</h2><p>我们需要沿着树向上移动，直至找到根节点。由于根节点的父亲是自己本身，因此递归的终止应该是pa[x]== x。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">dsu::find</span><span class="params">(<span class="type">size_t</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pa[x] == x? x: <span class="built_in">find</span>(pa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩">路径压缩</h2><p>查询操作的目的是找到该元素的根节点，它和其它元素如何联系并不重要。因此，我们可以将查询过程中的每个元素直接连接到根节点（更改其父节点为根节点），减小了树的深度，加快了后续查询。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">dsu::find</span><span class="params">(<span class="type">size_t</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pa[x] == x? x: (pa[x] = <span class="built_in">find</span>(pa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> ‘树形数组’ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>[题解][生贺]洛谷P1005-矩阵取数游戏</title>
      
      <link href="/2025/03/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8D%95%E9%A2%98%E8%A7%A3/2025-3-5-%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
      <url>/2025/03/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8D%95%E9%A2%98%E8%A7%A3/2025-3-5-%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1id="题解生贺洛谷p1005-矩阵取数游戏">[题解][生贺]洛谷P1005-矩阵取数游戏</h1><style>    .red{        color:red;        font-weight:600; //bold为700，normal为400    }    .lbold{        font-weight:bold;        font-size:24px; //默认16px    }    .bold{        font-weight: bold;    }</style><script type="text/javascript">  if (typeof MathJax === 'undefined') {    window.MathJax = { loader: { load: ['$tex', '$svg'], async: true } };  }</script><blockquote><p>主要思路构建: 2025.3.3</p><p>最终攻破:2025.3.3</p><p>文章撰写:2025.3.3 - 2025.3.4</p></blockquote><blockquote><p>感谢朋友的生日礼物，如封面图所示，miku可爱捏，晕晕晕。</p></blockquote><blockquote><p>为了庆祝生日，写了这篇题解，预期于生日当天发布(3.5)。</p><p>可惜3月3号爆发感冒，不知道生日那天会不会好~(QAQ)。</p><p>P1005 矩阵取数游戏这道题是我在大一上时遇见的，初次想用贪心，发现贪心走不通，后面看到标签有动态规划，感觉这十分高级，浅浅了解到了各种算法。如今约一年后的大二下终于做出来了。这道题算是我故意留到生日前夕做的（尽管对是否能做出来没底）。动态规划我并没有系统性地学习，我对题目的态度是“靠自己“全力尽力做出来，之前只做出来几道一维dp，于思路构建时才发现这可能是二维dp，我很高兴凭着自己一步一步地推理得到了正确答案。另外这道题还需要高精度，我拿之前写过的凑上，测试点过不了，后来发现是max函数未重构以及对0这个特殊数字没有进行特殊处理导致的。总归言之，可喜可贺，可喜可贺。</p></blockquote><h2 id="题目">题目</h2><p>[P1005 <a href="https://www.luogu.com.cn/problem/P1005">NOIP 2007提高组] 矩阵取数游戏 - 洛谷</a></p><blockquote><h1 id="p1005-noip-2007-提高组-矩阵取数游戏">P1005 [NOIP 2007 提高组]矩阵取数游戏</h1><h2 id="题目描述">题目描述</h2><p>帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 <spanclass="math inline">\(n \times m\)</span> 的矩阵，矩阵中的每个元素 <spanclass="math inline">\(a_{i,j}\)</span> 均为非负整数。游戏规则如下：</p><ol type="1"><li>每次取数时须从每行各取走一个元素，共 <spanclass="math inline">\(n\)</span> 个。经过 <spanclass="math inline">\(m\)</span> 次后取完矩阵内所有元素；</li><li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li><li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 =被取走的元素值 <span class="math inline">\(\times 2^i\)</span>，其中<span class="math inline">\(i\)</span> 表示第 <spanclass="math inline">\(i\)</span> 次取数（从 <spanclass="math inline">\(1\)</span> 开始编号）；</li><li>游戏结束总得分为 <span class="math inline">\(m\)</span>次取数得分之和。</li></ol><p>帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。</p><h2 id="输入格式">输入格式</h2><p>输入文件包括 <span class="math inline">\(n+1\)</span> 行：</p><p>第一行为两个用空格隔开的整数 <span class="math inline">\(n\)</span>和 <span class="math inline">\(m\)</span>。</p><p>第 <span class="math inline">\(2\sim n+1\)</span> 行为 <spanclass="math inline">\(n \times m\)</span> 矩阵，其中每行有 <spanclass="math inline">\(m\)</span> 个用单个空格隔开的非负整数。</p><h2 id="输出格式">输出格式</h2><p>输出文件仅包含 <span class="math inline">\(1\)</span>行，为一个整数，即输入矩阵取数后的最大得分。</p><h2 id="输入输出样例-1">输入输出样例 #1</h2><h3 id="输入-1">输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 2 3</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><h3 id="输出-1">输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">82</span><br></pre></td></tr></table></figure><h2 id="说明提示">说明/提示</h2><p><strong>【数据范围】</strong></p><p>对于 <span class="math inline">\(60\%\)</span> 的数据，满足 <spanclass="math inline">\(1\le n,m\le 30\)</span>，答案不超过 <spanclass="math inline">\(10^{16}\)</span>。<br />对于 <span class="math inline">\(100\%\)</span> 的数据，满足 <spanclass="math inline">\(1\le n,m\le 80\)</span>，<spanclass="math inline">\(0\le a_{i,j}\le1000\)</span>。</p><p><strong>【题目来源】</strong></p><p>NOIP 2007 提高第三题。</p></blockquote><h2 id="初步思路">初步思路</h2><p>对于这个矩阵取数游戏而言，我们想要取得矩阵的最大得分，其实就是取得矩阵中每一行的最大得分，我们设置这个求解函数为FUN(inta[], int low, int high),我们可以很轻松地得到完成任务的递归函数(尽管它在问题规模很大时，时间效率低)：</p><center><strong>Fun(a,low,high) = 2*max(a[low]+Fun(a,low+1,high),a[high]+Fun(a,low,high-1))</strong></center><p>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int Fun(int a[],int low, int high)&#123;</span><br><span class="line">if(low == high) return 2*a[low];</span><br><span class="line">else if(low &lt; high)&#123;</span><br><span class="line">return 2*max(a[low]+Fun(a,low+1,high),a[high]+Fun(a,low,high-1));</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这样的代码无法满足测试点的需求，他的时间复杂度是<b>指数级</b>的。我们不禁思考，这样的递归运算中存在大量的<b>重复运算</b>吗？<b style="font-size:24px">是的！</b>例如，对于Fun(a,0,0)，有Fun(a,1,0)和Fun(a,0,1)都调用了，并且它们自身也被<b>重复调用</b>了！接下来，我们的尝试是，<span class='red'>动态规划算法</span>。</p><h2 id="主要思路状态转移方程的构建">主要思路（状态转移方程的构建）</h2><p>设置<code>dp[n][n]</code>,其中 一维为high, 二维为low.设它们分别为i、j 我们得到状态转移方程如下:</p><center class ="lbold">dp[i][j] = 2*max(a[i]+dp[i+1][j],a[j]+dp[i][j-1])</center><p>同时，对于dp[i][i],dp[i][i] = a[i]并且，j一定大于等于i（low不能高于high）我们知道了循环起点一定和已知的<b>dp[i][i]</b>有关,而循环的终点应该是<b>dp[0][n-1]</b>。</p><p>也就是说，对这个矩阵而言，我们已知正对角线的元素，所求为上三角顶点元素，我们根据动态转移方程，不妨知道dp[i][j]<span class="red">取决于左和下的值</span>,于是<span class="red">loop应该是自上向右的</span>，也就是i=n-1,且i++ ; j=i 且 j++,这是一个螺旋上升的过程，i从n-1开始，使得dp[i][j]求解得到了dp[i+1][j]的一个前提，之后j再从i开始向右，使dp[i][j]也有了另一个前提dp[i][j-1]。当然，我这套做法是<span class="red">先满足下再满足左</span>，亦可以是<span class="red">先满足左再满足下</span>，只不过此时嵌套循环的次序要发生改变罢了。</p><p>于是我们得到:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Fun</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[n][n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">dp[i][j] =  <span class="number">2</span>*<span class="built_in">max</span>(a[i]+dp[i<span class="number">+1</span>][j],a[j]+dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>*a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终代码long-long不够满足测试集">最终代码（longlong不够满足测试集）</h2><p>使用了自己写的高精度,这里使用的是string类型，其实使用vector&lt;int&gt;也可以。</p><p>当然还有c++自带的__int128_t，我还不会用( )</p><p>(重构了max函数，由于忘记了这一点走了弯路，因为字符串的比较是字典序而非数值大小)</p><p>最终代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string <span class="keyword">operator</span>+(string a, string b)&#123;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> posa = a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> posb = b.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">while</span>(posa &gt;= <span class="number">0</span> || posb&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> tema = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temb =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(posa&gt;=<span class="number">0</span>)</span><br><span class="line">        tema = (<span class="type">int</span>)(a[posa]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(posb&gt;=<span class="number">0</span>)</span><br><span class="line">        temb = (<span class="type">int</span>)(b[posb]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> temp = tema + temb + c;</span><br><span class="line">        c = temp/<span class="number">10</span>;</span><br><span class="line">        temp %= <span class="number">10</span>;</span><br><span class="line">        res = (<span class="type">char</span>)(temp+<span class="string">&#x27;0&#x27;</span>)+ res;</span><br><span class="line">        posa--;</span><br><span class="line">        posb--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">        res = (<span class="type">char</span>)(c+<span class="string">&#x27;0&#x27;</span>) + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string <span class="keyword">operator</span>*(string a, string b)&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> posa = a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> posb = b.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b.<span class="built_in">length</span>() &gt; a.<span class="built_in">length</span>())&#123;</span><br><span class="line">        string temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&quot;0&quot;</span> || b==<span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(posb&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp = (<span class="type">int</span>)(b[posb] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        string cell;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span>(posa&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> t = (<span class="type">int</span>)(a[posa] - <span class="string">&#x27;0&#x27;</span>) * temp + c;</span><br><span class="line">            c = t /<span class="number">10</span>;</span><br><span class="line">            t %= <span class="number">10</span>;</span><br><span class="line">            cell = (<span class="type">char</span>)(t+<span class="string">&#x27;0&#x27;</span>) + cell;</span><br><span class="line">            posa--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="number">0</span>) cell = (<span class="type">char</span>)(c+<span class="string">&#x27;0&#x27;</span>)+ cell;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;b.<span class="built_in">length</span>()-posb &amp;&amp; cell!=<span class="string">&quot;0&quot;</span>; i++) cell = cell+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res = res+cell;</span><br><span class="line">        posa = a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">        posb --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">max</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">length</span>() == b.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>()) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Fun</span><span class="params">(string a[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">string dp[n][n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(a[i]+dp[i<span class="number">+1</span>][j],a[j]+dp[i][j<span class="number">-1</span>])* <span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = a[i]*<span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string a[n][m];</span><br><span class="line">    string total = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        total = <span class="built_in">Fun</span>(a[i],m)+total;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>[前端]HTML+CSS教程</title>
      
      <link href="/2025/01/11/HTML%E4%B8%8ECSS/"/>
      <url>/2025/01/11/HTML%E4%B8%8ECSS/</url>
      
        <content type="html"><![CDATA[<h1 id="html">HTML</h1><blockquote><p>参考视频:<ahref="https://www.bilibili.com/video/BV1kM4y127Li?spm_id_from=333.788.videopod.episodes&amp;vd_source=e0c65757487f00d50e17c6407e3d925b">前端Web开发HTML5+CSS3+移动web视频教程，前端web入门首选黑马程序员_哔哩哔哩_bilibili</a></p><p>css弹性盒子起，参考菜鸟教程</p></blockquote><p>定义：超文本标记语言</p><p>超文本: 链接</p><p>编辑器：<a href="https://www.jetbrains.com/webstorm/">WebStorm</a>或<a href ="https://code.visualstudio.com/">VsCode</a></p><h2 id="标签语法">标签语法</h2><p><strong>双标签</strong>：</p><p>需要包括文字内容的标签</p><p>语法： 开始标签–文字–结束标签</p><p>例如: <code>&lt;strong&gt;文字内容&lt;/strong&gt;</code></p><p>结束标签比开始标签多 /， 表示结束的地方。</p><p><strong>单标签</strong>：</p><p>不需要文字内容的标签</p><p>例如水平线标签<code>hr</code></p><h2 id="html的基本骨架">HTML的基本骨架</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        网页主体</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>VS Code快速生成骨架:</p><p>在HTML文件中,<code>!+Enter/Tab</code>键</p><p><code>html</code> : 整个网页</p><p><code>head</code> : 网页头部</p><p><code>title</code> : 网页标题</p><p><code>body</code> : 网页主体</p><h2 id="标签的关系">标签的关系</h2><p>作用: 明确代码的书写位置</p><ul><li>父子关系(嵌套关系)</li><li>兄弟关系(并列关系)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此处，html与head和body为父子关系，head与body为兄弟关系。</p><h2 id="注释">注释</h2><p><code>&lt;!--注释内容--&gt;</code></p><h2 id="各种标签">各种标签</h2><h3 id="基本标签">基本标签</h3><table><thead><tr><th style="text-align: center;">功能</th><th style="text-align: left;">标签名</th><th style="text-align: left;">内容</th><th style="text-align: center;">单/双标签</th></tr></thead><tbody><tr><td style="text-align: center;">标题</td><td style="text-align: left;"><code>h1~h6</code> (数字代表标题级别)</td><td style="text-align: left;">使文字成为标题，加粗加大独占一行</td><td style="text-align: center;">双</td></tr><tr><td style="text-align: center;">段落</td><td style="text-align: left;"><code>p</code></td><td style="text-align: left;">独占一行，段落有间隙</td><td style="text-align: center;">双</td></tr><tr><td style="text-align: center;">换行</td><td style="text-align: left;"><code>br</code></td><td style="text-align: left;">换行</td><td style="text-align: center;">单</td></tr><tr><td style="text-align: center;">水平线</td><td style="text-align: left;"><code>hr</code></td><td style="text-align: left;">划分界限</td><td style="text-align: center;">单</td></tr></tbody></table><hr><h3 id="文本格式化标签">文本格式化标签</h3><blockquote><p>strong、em、ins、del自带强调含义（语义）</p></blockquote><table><thead><tr><th style="text-align: center;">功能</th><th style="text-align: center;">标签名</th><th style="text-align: center;">内容</th><th style="text-align: center;">单/双标签</th></tr></thead><tbody><tr><td style="text-align: center;">加粗</td><td style="text-align: center;"><code>strong</code>/<code>b</code></td><td style="text-align: center;"><strong>加粗</strong></td><td style="text-align: center;">双</td></tr><tr><td style="text-align: center;">倾斜</td><td style="text-align: center;"><code>em</code>/<code>i</code></td><td style="text-align: center;"><em>倾斜</em></td><td style="text-align: center;">双</td></tr><tr><td style="text-align: center;">下划线</td><td style="text-align: center;"><code>ins</code>/<code>u</code></td><td style="text-align: center;"><ins>下划线</ins></td><td style="text-align: center;">双</td></tr><tr><td style="text-align: center;">删除线</td><td style="text-align: center;"><code>del</code>/<code>s</code></td><td style="text-align: center;"><del>删除线</del></td><td style="text-align: center;">双</td></tr></tbody></table><hr><h3 id="图像标签">图像标签</h3><p><code>&lt;img&gt;</code> : 插入图片</p><p>其必须属性为<code>src</code>, 指定图片的URL</p><p>用例: <code>&lt;img src="图片的URL"&gt;</code></p><p>若用本地图片，URL既可以用绝对路径，也可以用相对路径(使用<code>./</code>从程序所在位置(的文件夹)出发查找目标文件)</p><p>在<code>./</code>前每加一个点<code>.</code>，意味着从上一级文件夹出发访问</p><p>例如: <code>./img/hello.jpg</code></p><p><mark>属性之间用空格’ ’隔开</mark></p><table><thead><tr><th style="text-align: center;">属性</th><th style="text-align: center;">作用</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr><td style="text-align: center;">alt</td><td style="text-align: center;">替换文本</td><td style="text-align: center;">图片无法显示的时候显示的文字</td></tr><tr><td style="text-align: center;">title</td><td style="text-align: center;">提示文本</td><td style="text-align: center;">鼠标悬停在图片上的提示文字</td></tr><tr><td style="text-align: center;">width</td><td style="text-align: center;">图片的宽度</td><td style="text-align: center;">值为数字，没有单位</td></tr><tr><td style="text-align: center;">height</td><td style="text-align: center;">图片的高度</td><td style="text-align: center;">值为数字，没有单位</td></tr></tbody></table><blockquote><p>浏览器缩放图片是等比缩放的，宽缩小，高也可能缩小</p></blockquote><hr><h3 id="超链接标签">超链接标签</h3><p><code>&lt;a href="网址的URL"&gt;文字&lt;/a&gt;</code></p><p>href属性写<code>#</code>，表示空链接，<a href=#>不会跳转</a></p><table><thead><tr><th>其它属性</th><th>作用</th></tr></thead><tbody><tr><td>target=“_blank”</td><td>新窗口跳转页面</td></tr></tbody></table><hr><h3 id="音频标签">音频标签</h3><p><code>&lt;audio&gt;&lt;/audio&gt;</code></p><table><thead><tr><th style="text-align: center;">属性</th><th style="text-align: center;">作用</th><th>说明</th></tr></thead><tbody><tr><td style="text-align: center;">src(必须属性)</td><td style="text-align: center;">音频URL</td><td>支持格式：MP3</td></tr><tr><td style="text-align: center;">controls</td><td style="text-align: center;">显示音频控制面板</td><td></td></tr><tr><td style="text-align: center;">loop</td><td style="text-align: center;">循环播放</td><td></td></tr><tr><td style="text-align: center;">autoplay</td><td style="text-align: center;">自动播放</td><td>为了提升用户体验，浏览器一般禁用</td></tr></tbody></table><h3 id="视频标签">视频标签</h3><p><code>&lt;video&gt;&lt;/video&gt;</code></p><p>属性: src、controls、loop、autoplay、muted(静音播放)</p><p>autoplay: 对于静音视频浏览器不禁用。</p><hr><h3 id="列表">列表</h3><p>分类:无序列表<code>ul</code>、有序列表<code>ol</code>、定义列表<code>dl</code></p><p><strong>无序列表</strong></p><p><code>ul</code> 嵌套<code>li</code>,<code>ul</code>是无序列表，<code>li</code>是列表条目</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码效果：</p><blockquote><ul>   <li>第一项</li>   <li>第二项</li></ul></blockquote><p>注意：</p><ul>    <li>ul标签只能包括li</li>    <li>li里可包括其它标签</li></ul><p><strong>有序列表</strong></p><p><code>ol</code>嵌套<code>li</code>, <code>ol</code>是有序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码效果:</p><blockquote><ol>    <li>第一项</li>    <li>第二项</li></ol></blockquote><p><strong>定义列表</strong></p><p><code>dl</code>嵌套<code>dt</code>和<code>dd</code>,<code>dt</code>是定义列表的标题, dd是定义列表的描述/详情</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><dl>   <dt>列表标题</dt>   <dd>描述1</dd>   <dd>描述2</dd></dl></blockquote><p><code>dl</code>里面只能包含<code>dt</code>和<code>dd</code></p><p><code>dt</code>和<code>dd</code>可以包含其它内容</p><h3 id="表格">表格</h3><h4 id="基本使用">基本使用</h4><p><code>table</code>嵌套<code>tr</code>,<code>tr</code>嵌套<code>td</code>/<code>th</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;--!border属性为表格边框宽度,可无--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标签名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>说明<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>table<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>tr<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>行<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>td<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>th<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表头单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果展示:</p><table border="1">    <tr>        <th>标签名</th>        <th>说明</th>    </tr>    <tr>        <td>table</td>        <td>表格</td>    </tr>    <tr>        <td>tr</td>        <td>行</td>    </tr>    <tr>        <td>td</td>        <td>内容单元格</td>    </tr>    <tr>        <td>th</td>        <td>表头单元格</td>    </tr></table><p><strong>表格结构标签</strong></p><table><thead><tr><th>标签</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>thead</td><td>表格头部</td><td>表格头部内容</td></tr><tr><td>tbody</td><td>表格主体</td><td>主要内容区域</td></tr><tr><td>tfoot</td><td>表格底部</td><td>汇总信息区域</td></tr></tbody></table><p>作用：使结构更清晰，无效果。</p><p>示例代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>标签名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>说明<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>table<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>更改展示<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="合并多元格">合并多元格</h4><p>合并多元格的步骤:</p><p>1.明确合并的目标</p><p>2.保留<mark>最左最上</mark>的单元格，添加属性（取值是数字，表示需要合并的单元格数量）</p><ul><li><p>跨行合并，保留最上单元格，添加属性<code>rowspawn</code></p></li><li><p>跨列合并，保留最左单元格，添加属性<code>colspawn</code></p></li></ul><p>3.删除其他单元格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>99<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>98<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码效果：</p><table border="1">    <thead>        <tr>            <th>姓名</th>            <th>语文</th>            <th>数学</th>        </tr>    </thead>    <tbody>        <tr>            <td>张三</td>            <td>99</td>            <td rowspan="2">100</td>        </tr>        <tr>            <td>李四</td>            <td>98</td>        </tr>    </tbody></table><h3 id="表单">表单</h3><p>作用: 收集用户信息</p><h4 id="input标签"><code>input</code>标签</h4><p>其<code>type</code>属性不同，功能不同</p><table><thead><tr><th style="text-align: center;">type属性值</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr><td style="text-align: center;">text</td><td style="text-align: center;">文本框，用于输入单行文本</td></tr><tr><td style="text-align: center;">password</td><td style="text-align: center;">密码框，输入密码变成*</td></tr><tr><td style="text-align: center;">radio</td><td style="text-align: center;">单选框</td></tr><tr><td style="text-align: center;">checckbox</td><td style="text-align: center;">多选框</td></tr><tr><td style="text-align: center;">file</td><td style="text-align: center;">上传文件</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文本框<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">密码框<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">单选框<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span>女</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">多选框<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文本框<input type="text"></p>  <br><p>密码框<input type="password"></p>  <br><p>单选框<input type="radio" name="gender">男<input type="radio" name="gender">女</p>  <br><p>多选框<input type="checkbox"></p>  <br><p>上传文件<input type="file"></p><p><strong>input标签占位文本</strong></p><p><code>&lt;input type="..." placeholder="提示信息"&gt;</code></p><p><strong>单选框-radio</strong></p><table><thead><tr><th>属性名</th><th>作用</th><th>特殊说明</th></tr></thead><tbody><tr><td>name</td><td>控件名称</td><td>控件分组，同组只能选中一个</td></tr><tr><td>checked</td><td>默认选中</td><td>属性名和属性值相同，简写为一个单词(即不需要被赋值)</td></tr></tbody></table><p><strong>上传文件-file</strong></p><p>默认情况只能上传一个，想要能同时上传多个，需要有<mark>multiple</mark>属性。</p><p><strong>多选框-checkbox</strong></p><p>又称复选框</p><p>默认选中属性<mark>checked</mark></p><h4 id="下拉菜单">下拉菜单</h4><p><code>select</code>嵌套<code>option</code></p><p><mark>selected</mark>属性表示默认选中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>重庆<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><select>    <option>北京</option>    <option>上海</option>    <option>广州</option>    <option>深圳</option>    <option selected>重庆</option></select>#### 文本域<p>作用:<mark>多行</mark>输入文本的表单控件</p><p>标签:<code>textarea</code>, 双标签</p><p>边框可拖拽,但一般禁用。可以有<code>col</code>、<code>row</code>设置尺寸，但一般是css负责。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>请输入评论<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><textarea>请输入评论</textarea><h4 id="label标签">label标签</h4><p>作用: 网页中, 某个标签的说明文本</p><p>可使用label增大点击范围</p><p>支持: 文本框、密码框、上传文件、单选框、多选框、文本域等。</p><ul><li>写法一<ul><li>lable标签只包裹内容，不包裹表单控件</li><li>设置lable标签的<code>for</code>属性值，和表单控件的<code>id</code>属性值相同</li></ul></li><li>写法二<ul><li>使用lable标签包裹文字和表达那控件，不需要属性。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">id</span>=<span class="string">&quot;man&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">lable</span> <span class="attr">for</span>=<span class="string">&quot;man&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lable</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br></pre></td></tr></table></figure><p><input type="radio" name="gender" id="man"><lable for="man">男</lable><lable><input type="radio">女</lable></p><h4 id="按钮">按钮</h4><p><code>button</code>双标签,具有<code>type</code>属性</p><table><thead><tr><th>type属性值</th><th>说明</th></tr></thead><tbody><tr><td>submit</td><td>提交按钮，点击可以提交数据到后台（默认功能）</td></tr><tr><td>reset</td><td>重置按钮，点击后将表单控件恢复默认值</td></tr><tr><td>button</td><td>普通按钮，默认没有功能，一般配合JavaScript使用</td></tr></tbody></table><p>配合<code>form</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;--!发送数据的地址--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果:</p><form action="">    用户名:<input type="text">    <br><br>    密码:<input type="password">    <br><br>    <button type = "reset">重置</button></form>#### 无语义的布局标签与字符实体<p><strong>无语义的布局标签</strong></p><p>作用: 布局网页(划分网页区域，摆放内容)</p><ul><li>div: 独占一行 (被称作大盒子)</li><li>span: 不换行 (被称作小盒子)</li></ul><p><strong>字符实体</strong></p><p>作用：在网页中显示预留字符</p><table><thead><tr><th>显示结果</th><th>描述</th><th>字符实体</th></tr></thead><tbody><tr><td></td><td>空格</td><td>&amp;nbsp</td></tr><tr><td>&lt;</td><td>小于号</td><td>&amp;lt</td></tr><tr><td>&gt;</td><td>大于号</td><td>&amp;gt</td></tr></tbody></table><p>若不使用字符实体，则即使连续敲出多个空格，网页只显示一个</p><p>故若想显示&lt;p&gt;则使用&amp;ltp&amp;gt</p><h1 id="css">CSS</h1><p>定义： 层叠样式表(Cascading Style Sheets),是一种样式表语言，用来描述HTML文档的呈现。</p><p>head标签里放</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/*选择器&#123;&#125;*/</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/*CSS属性*/</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*文字颜色*/</span></span></span><br><span class="line"><span class="language-css">       <span class="attribute">color</span>: red; </span></span><br><span class="line"><span class="language-css">        <span class="comment">/*字号*/</span></span></span><br><span class="line"><span class="language-css">       <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="css引入方式">CSS引入方式</h2><ul><li><p>内部样式表: 学习使用</p><ul><li><p>CSS代码写在<mark>style</mark>标签里面</p><p>在head标签里放</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/*选择器&#123;&#125;*/</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/*CSS属性*/</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*文字颜色*/</span></span></span><br><span class="line"><span class="language-css">       <span class="attribute">color</span>: red; </span></span><br><span class="line"><span class="language-css">        <span class="comment">/*字号*/</span></span></span><br><span class="line"><span class="language-css">       <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>外部样式表： 开发使用</p><ul><li>CSS代码写在单独的CSS文件中</li><li>在HTML使用<mark>link</mark>标签引入(也放在head内)</li></ul></li></ul><p>​ <code>&lt;link rel="stylesheet" href="./my.css"&gt;</code></p><ul><li><p>行内样式</p><ul><li><p>CSS写在标签的style属性值里</p><p><code>&lt;div style="color:red; font-size:20px;"&gt;这是div标签&lt;/div&gt;</code></p></li></ul></li></ul><p>效果展示:</p><div style="color:red; font-size:20px;">这是div标签</div><h2 id="基础选择器">基础选择器</h2><p>作用: 查找标签，设置样式</p><p>基础选择器</p><ul><li>标签选择器</li><li>类选择器</li><li>id选择器</li><li>通配符选择器</li></ul><h3 id="标签选择器">标签选择器</h3><p>使用<mark>标签名</mark>作为选择器,即选中同名标签设置相同的样式。</p><p>例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>缺点:无法差异化同名标签的显示效果</p><h3 id="类选择器">类选择器</h3><p>作用: 查找标签，<mark>差异化</mark>设置标签的显示效果。</p><p>步骤</p><ul><li>定义类选择器 –&gt; .类名</li><li>使用类选择器 –&gt; 标签添加class=“类名”</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">/*定义类选择器*/</span><br><span class="line">    .red&#123;</span><br><span class="line">color:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;sytle&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--使用类选择器--&gt;</span><br><span class="line">&lt;div class=&quot;red&quot;&gt;这是div&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="id选择器">id选择器</h3><p>查找标签，<mark>差异化</mark>设置标签的显示效果。</p><p>场景: id选择器一般配合JavaScript使用，很少用来设置CSS样式</p><p>步骤</p><ul><li>定义id选择器 –&gt; #id名</li><li>使用id选择器 –&gt; id=“id名”</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">/*定义id选择器*/</span><br><span class="line">    #red&#123;</span><br><span class="line">color:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;sytle&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--使用id选择器--&gt;</span><br><span class="line">&lt;div id=&quot;red&quot;&gt;这是div&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>规则:</p><p><mark>同一个id选择器在一个页面只能使用一次</mark></p><h3 id="通配符选择器">通配符选择器</h3><p>作用：查找页面所有标签，设置标签为相同样式</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">* &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;style&gt;</span><br></pre></td></tr></table></figure><p>使全局颜色为红</p><h2 id="文字控制属性">文字控制属性</h2><table><thead><tr><th>描述</th><th>属性</th></tr></thead><tbody><tr><td>字体大小</td><td>font-size</td></tr><tr><td>字体粗细</td><td>font-weight</td></tr><tr><td>字体倾斜</td><td>font-style</td></tr><tr><td>行高</td><td>line-height</td></tr><tr><td>字体族</td><td>font-family</td></tr><tr><td>字体复合属性</td><td>font</td></tr><tr><td>文本缩进</td><td>text-indent</td></tr><tr><td>文本对齐</td><td>text-align</td></tr><tr><td>修饰线</td><td>text-decoration</td></tr><tr><td>颜色</td><td>color</td></tr></tbody></table><h3 id="字体大小">字体大小</h3><ul><li>属性名: font-size</li><li>属性值: 文字尺寸(单位px)</li></ul><h3 id="字体粗细">字体粗细</h3><p>属性名:font-weight</p><p>属性值</p><ul><li>数字</li></ul><table>    <tr>        <td>正常</td>        <td>400</td>    </tr>    <tr>        <td>加粗</td>        <td>700</td>    </tr></table><ul><li>关键字</li></ul><table>    <tr>        <td>正常</td>        <td>normal</td>    </tr>    <tr>        <td>加粗</td>        <td>bold</td>    </tr></table><h3 id="字体样式是否倾斜">字体样式(是否倾斜)</h3><p>常见作用：清除文字默认的倾斜效果</p><p>属性名: font-style</p><p>属性值</p><ul><li>正常(不倾斜): normal</li><li>倾斜: italic</li></ul><h3 id="行高">行高</h3><p>作用: 设置多行文本的间距</p><p>属性名: line-height</p><p>属性值:</p><ul><li>数字+px</li><li>数字(当前font-size属性值的倍数,)</li></ul><p>行高属性值的计算:字体大小+上下间距(一行文字的顶端(底端)到下一行文字的顶端(底端)的距离)</p><p>垂直居中技巧：行高属性值和盒子高度一样。(只适用单行)</p><h3 id="字体族">字体族</h3><p>属性名: font-family</p><p>属性值：字体名</p><p><code>font-family: 楷体</code></p><blockquote><p>font-family属性值可以书写多个字体名，各个字体名用逗号隔开，执行顺序是从左向右依次查找。</p></blockquote><blockquote><p>建议适用sans-serif为无衬线字体(无起笔收笔)</p></blockquote><h3 id="font属性">font属性</h3><p>font是一个可以实现上述的所有效果的复合属性，是一种属性的简写方式，属性值用空格隔开</p><p><mark>font必须写自豪和字体，否则不生效</mark></p><blockquote><p>font: italic 700 30px/2 楷体</p><p>// 文字倾斜、文字加粗、字体大小是30px\行高2倍、楷体</p></blockquote><h3 id="文本缩进">文本缩进</h3><p>段落首行前面空出</p><p>属性名: text-indent</p><p>属性值:</p><ul><li>数字+px</li><li>数字+em(1em = 当前标签字号大小)</li></ul><p>例子:</p><p><code>text-indent: 2em</code> //空2格</p><h3 id="文本对齐">文本对齐</h3><p>作用: 控制内容水平对齐</p><p>属性名: text-align</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>left</td><td>左对齐(默认)</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>right</td><td>右对齐</td></tr></tbody></table><h3 id="修饰线">修饰线</h3><p>属性名: text-decoration</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>none</td><td>无</td></tr><tr><td>underline</td><td>下滑线</td></tr><tr><td>line-through</td><td>删除线</td></tr><tr><td>overline</td><td>上划线</td></tr></tbody></table><h3 id="文字颜色">文字颜色</h3><p>属性名: color</p><table><thead><tr><th>颜色表示方式</th><th>属性值</th><th>说明</th><th>使用场景</th></tr></thead><tbody><tr><td>颜色关键字</td><td>颜色引文单词</td><td>red、green…</td><td>学习测试</td></tr><tr><td>rgb表示法</td><td>rgb(r,g,b)</td><td>r,g,b表示红绿蓝三原色，取值0-255</td><td>了解</td></tr><tr><td>rgba表示法</td><td>rgba(r,g,b,a)</td><td>a表示透明度,取值0-1</td><td>开发使用，实现透明</td></tr><tr><td>十六进制表示法</td><td>#RRGGBB</td><td>#000000,#ffcc00,简写#000,#fc0</td><td>开发时使用</td></tr></tbody></table><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color:red;</span><br><span class="line">color: rgb(0,255,1);</span><br><span class="line">color: rgba(0,255,1,0.5);</span><br><span class="line">color: #fc0;</span><br></pre></td></tr></table></figure><h3 id="调试工具">调试工具</h3><p>作用: 检查、调试代码</p><p>1.打开调试工具</p><ul><li>F12</li></ul><p>2.使用调试工具</p><p>通过选择工具选择查看区域，可以试着取消css功能，若代码有误会有黄色三角提示。</p><h2 id="复合选择器">复合选择器</h2><p>定义: 由两个或多个基础选择器</p><p>作用: 更准确、更高效的选择目标元素(标签)</p><h3 id="后代选择器">后代选择器</h3><p>后代选择器: 选中某元素的后代元素。</p><p>选择器写法:父选择器、子选择器{css属性}，父子选择器之间用空格隔开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div span&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">/*非div后代,颜色正常*/</span><br><span class="line">&lt;span&gt; span标签&lt;/span&gt;</span><br><span class="line">/*为div后代,颜色正常*/</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span&gt;这是div的儿子span&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="子代选择器">子代选择器</h3><p>只能选中子代，非子代的后代不会被选中</p><p>写法: 父选择器&gt;子选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &gt; span&#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并集选择器">并集选择器</h3><p>选中多组标签设置相同样式</p><p>写法: 选择器之间用<code>,</code>隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p, </span><br><span class="line">div, </span><br><span class="line">span &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交集选择器">交集选择器</h3><p>选中同时满足多个条件的元素。</p><p>写法: 选择器1选择器2{CSS属性},选择器之间连写,没有任何符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*.box为类*/</span><br><span class="line">p.box&#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;p class=&quot;box&quot;&gt;红色&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="伪类选择器">伪类选择器</h2><p>伪类表示元素状态， 选中元素的某个状态设置样式。</p><p>鼠标悬停状态:</p><p>选择器:hover{css属性}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:hover&#123;color:red;&#125;</span><br><span class="line">.box:hover&#123;color:red;&#125;</span><br></pre></td></tr></table></figure><h3 id="伪类-超链接">伪类-超链接</h3><table><thead><tr><th>选择器</th><th>作用</th></tr></thead><tbody><tr><td>:link</td><td>访问前</td></tr><tr><td>:visited</td><td>访问后</td></tr><tr><td>:hover</td><td>鼠标悬停</td></tr><tr><td>:active</td><td>点击时(激活)</td></tr></tbody></table><p>提示：如果要给超链接设置以上四个状态，需要按LVHA的顺序书写。</p><h2 id="css特性">CSS特性</h2><h3 id="继承性">继承性</h3><p>定义: 子级默认继承父级的文字控制属性。</p><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">body&#123;</span><br><span class="line">font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;受body影响，字体大小变为30px&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>提示: 自己有的样式，会覆盖从父级继承的样式（其它没有的仍会继承）</p><h3 id="层叠性">层叠性</h3><p>特点:</p><ul><li>相同的属性会覆盖: 后面的CSS属性覆盖前面的CSS属性</li><li>不同的属性会叠加: 不同的CSS属性都生效</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">        <span class="attribute">font-weight</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">color</span>:green;</span><br><span class="line">        <span class="attribute">font-size</span>:<span class="number">700</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*等同于*/</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">    <span class="attribute">font-weight</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">700</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先级">优先级</h3><p>又称权重，基于不同种类的选择器的匹配规则。</p><p>规则: 选择器优先级高的样式生效。</p><p>公式: 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt;行内样式 &lt; !important</p><p>(选中标签的范围越大，优先级越低)</p><p>!import为提权功能，使其权重最高，放在属性值<code>;</code>前慎用。</p><p><strong>叠加计算规则</strong></p><p>叠加计算: 如果是复合选择器，则需要权重叠加计算。</p><p>公式: (每一级不存在进位)</p><p>(行内样式，id选择器个数, 类选择器个数, 标签选择器个数)</p><p>规则:</p><ul><li>从左向右依次比较个数，同一级个数多的优先级高，如果个数相同则向后比较</li><li>!important权重最高</li><li>继承权重最低</li></ul><h2 id="emmet写法">Emmet写法</h2><p>代码的简写方式，输入缩写VS Code会自动生成对应的代码.</p><ul><li>HTML</li></ul><p>​</p><table><thead><tr><th>说明</th><th>标签结构</th><th>Emmet</th></tr></thead><tbody><tr><td>类选择器</td><td><code>&lt;div class="box"&gt;&lt;/div&gt;</code></td><td>标签名.类名</td></tr><tr><td>id选择器</td><td><code>&lt;div id="box"&gt;&lt;/div&gt;</code></td><td>标签名#Id名</td></tr><tr><td>同级标签</td><td><code>&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</code></td><td>div+p</td></tr><tr><td>父子级标签</td><td><code>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</code></td><td>div&gt;p</td></tr><tr><td>多个相同标签</td><td><code>&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;</code></td><td>span*3</td></tr><tr><td>有内容的标签</td><td><code>&lt;div&gt;内容&lt;/div&gt;</code></td><td>div(内容)</td></tr></tbody></table><ul><li>CSS</li></ul><p>大多数简写方式为属性单词的首字母</p><h2 id="背景属性">背景属性</h2><h3 id="背景颜色">背景颜色</h3><p>网页中的背景颜色</p><p>属性名: background-color</p><p>属性值: 颜色</p><h3 id="背景图">背景图</h3><p>网页中，使用背景图实现装饰性的图片效果。</p><p>属性名: background-image (bgi)</p><p>属性值: url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">height: 400px;</span><br><span class="line">/*背景图默认平铺*/</span><br><span class="line">background-image: url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背景图平铺方式">背景图平铺方式</h3><p>属性名:background-repeat</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>no-repeat</td><td>不平铺</td></tr><tr><td>repeat</td><td>平铺</td></tr><tr><td>repeat-x</td><td>水平方向平铺</td></tr><tr><td>repeat-y</td><td>垂直方向平铺</td></tr></tbody></table><h3 id="背景图位置">背景图位置</h3><p>属性名: background-position(bgp)</p><p>属性值: 水平方向位置 垂直方向位置</p><ul><li>关键字</li></ul><table><thead><tr><th>关键字</th><th>位置</th></tr></thead><tbody><tr><td>left</td><td>左侧</td></tr><tr><td>right</td><td>右侧</td></tr><tr><td>center</td><td>居中</td></tr><tr><td>top</td><td>顶部</td></tr><tr><td>bottom</td><td>底部</td></tr></tbody></table><ul><li>坐标（数字+px，正负都行,可与关键词混用)</li></ul><p>例如图片在左上角:</p><p><code>background-position: 0 0</code></p><p><code>background-position: left top</code></p><p>提示:</p><ul><li>关键字法，可以颠倒取值顺序</li><li>写一个关键字，另一个方向默认居中。写一个数字，其表示水平方向，垂直方向居中。</li></ul><h3 id="背景图缩放">背景图缩放</h3><p>属性名: background-size</p><p>属性值</p><ul><li>关键字</li></ul><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td>cover</td><td>等比例缩放至完全覆盖背景区域，可能背景图部分不见</td></tr><tr><td>contain</td><td>等比例缩放至刚好放入背景区域，可能北京区部分空白</td></tr></tbody></table><ul><li>百分比: 根据盒子尺寸计算图片大小</li><li>数字+单位</li></ul><h3 id="背景图固定">背景图固定</h3><p>作用: 背景不会随着元素的内容滚动(脱离)</p><p>属性名:background-attachment (bga)</p><p>属性值: fixed</p><h3 id="背景复合属性">背景复合属性</h3><p>属性名: background (bg)</p><p>属性值: 背景色、背景图、背景平铺方式、缩放…….（用空格隔开）</p><h2 id="显示模式">显示模式</h2><p>显示模式: 标签(元素)的显示方式</p><ul><li><p>块级元素 (例如div)</p><ul><li>独占一行</li><li>宽度默认是父级的100%</li><li>添加宽高属性生效</li></ul></li><li><p>行内元素 (例如span)</p><ul><li>一行共存多个，尺寸由内容撑开</li><li>添加宽高属性不生效</li></ul></li><li><p>行内块元素 (例如img)</p><ul><li>一行共存多个，默认尺寸由内容撑开</li><li>添加宽高属性生效</li></ul></li></ul><p><strong>转换显示模式</strong></p><p>属性名: display</p><p>属性值: block、inline-block、<em>inline(不常用)</em></p><h2 id="结构伪类选择器">结构伪类选择器</h2><p>作用: 根据元素的结构关系查找元素。</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E:first-child</td><td>查找第一个E元素</td></tr><tr><td>E:lastchild</td><td>查找最后一个E元素</td></tr><tr><td>E:nth-child(N)</td><td>查找第N个E元素（从1开始）</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">li:first-child&#123;</span><br><span class="line">background-color: green</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;li 1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>:nth-child（公式）</p><p>例如<code>li:nth-child(2n+1)&#123;&#125;</code></p><p>(此时n从0开始)</p><h2 id="伪元素选择器">伪元素选择器</h2><p>作用: 创建虚拟元素(伪元素)，用来摆放装饰性内容</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E::before</td><td>在E元素里面最前面添加一个伪元素</td></tr><tr><td>E:after</td><td>在E元素里面最后面添加一个伪元素</td></tr></tbody></table><ul><li>必须设置content:“ “属性。如果没有内容则留空</li><li>伪元素默认是行内显示模式</li><li>权重和标签选择器相同</li></ul><h2 id="pxcook">PxCook</h2><p>PxCook(像素大厨)是一款切图设计工具软件。支持PSD文件的文字、颜色、距离自动智能识别。</p><ul><li>开发面板（自动只能识别）</li><li>设计面板（手动测量尺寸和颜色）</li></ul><blockquote><p>弹幕说现在用蓝湖</p></blockquote><h2 id="盒子模型">盒子模型</h2><p>作用: 布局网页，摆放盒子和内容</p><h3 id="组成">组成</h3><p>盒子模型重要组成部分:</p><ul><li>内容 - width &amp; height</li><li>内边距 - padding (出现在内容于盒子边缘之间)</li><li>边框线 - border</li><li>外边距 - margin (出现在盒子外面)</li></ul><h3 id="边框线">边框线</h3><p>属性名: border (bd)</p><p>属性值: 边框线粗细(数字+单位) 线条样式 颜色</p><table><thead><tr><th>属性值</th><th>线条样式</th></tr></thead><tbody><tr><td>solid</td><td>实现</td></tr><tr><td>dashed</td><td>虚线</td></tr><tr><td>dotted</td><td>点线</td></tr></tbody></table><p>若要设置单方向边框线</p><p>属性名: border-方位名词(top、bottom、left、right)</p><h3 id="内边距">内边距</h3><p>作用: 设置内容与盒子边缘之间的距离</p><p>属性名: padding/padding-方位名词</p><p>属性值: 数字+单位</p><p>如果设置了方位名词，如果当前方向没有数值，默认值和对面一样。</p><h2 id="尺寸计算">尺寸计算</h2><ul><li><p>默认情况</p><p>盒子尺寸 = 内容尺寸 + border尺寸 + 内边距尺寸</p></li><li><p>结论: 给盒子加border/padding会撑大盒子</p></li><li><p>解决:</p><ul><li>手动做减法，宽高减掉border/padding的尺寸</li><li>内减模式: box-sizing: box-border</li></ul></li></ul><h3 id="外边距">外边距</h3><p>作用: 拉开两个盒子的距离</p><p>属性名: margin</p><p>属性值: 数字+单位</p><h2 id="弹性盒子">弹性盒子</h2><p>弹性盒子是 CSS3 的一种新的布局模式。</p><p>CSS3 弹性盒（ Flexible Box 或flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。</p><p>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p><p>弹性盒子由弹性容器和弹性子元素组成</p>]]></content>
      
      
      <categories>
          
          <category> web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构-栈</title>
      
      <link href="/2025/01/07/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
      <url>/2025/01/07/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前情提要: <ahref="https://blog.4fgr.xyz/2025/01/06/数据结构-线性表/">数据结构-线性表| 4FGR の Blog</a></p></blockquote><blockquote><p>参考资料: 数据结构与算法分析 –Mark Allen Weiss</p></blockquote><h1 id="栈模型">栈模型</h1><p>栈是限制在插入和删除在末端的线性表，这决定了它的特性是“后进先出“(LIFO)。在解决一些问题时，我们很容易想到通过栈这种结构来解决，例如，对多项式的求解。</p><p>对于栈而言，基本的操作是<em>Pop</em>和<em>Push</em>,尽管有时通过<em>Top</em>返回栈顶元素的值。</p><p><strong>注意</strong>：栈顶元素是栈中唯一可见的元素。</p><h1 id="栈的实现">栈的实现</h1><p>由于栈是一个表，因此任何实现表的方法都可以实现栈，这里给出两种方法：</p><h2 id="栈的数组实现">栈的数组实现</h2><p>为了讲解的便利和简洁，这里我们通过静态数组的方式实现，大家可以自己实现下动态分配的方法。</p><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;*<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initialStack</span><span class="params">(<span class="built_in">stack</span> s)</span>&#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>; <span class="comment">//置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(<span class="built_in">stack</span> s)</span>&#123; <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(<span class="built_in">stack</span> s)</span>&#123;   <span class="comment">//判断栈是否满</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == MAXSIZE<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(<span class="built_in">stack</span> s, <span class="type">int</span> &amp;e)</span>&#123; <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    e = s-&gt;data[s-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(<span class="built_in">stack</span> s, <span class="type">int</span> e)</span>&#123; <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">if</span>(isFull(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    s-&gt;data[++s-&gt;top] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTop</span><span class="params">(<span class="built_in">stack</span> s, <span class="type">int</span> &amp;e)</span>&#123; <span class="comment">//取栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    e = s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="栈的链表实现">栈的链表实现</h2><p>链式栈的实现更加灵活，不用像顺序栈被空间所束缚。</p><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initialStack</span><span class="params">(<span class="built_in">stack</span> &amp;s)</span>&#123;</span><br><span class="line">    s = (<span class="built_in">stack</span>)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(<span class="built_in">stack</span> s)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;next == <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(<span class="built_in">stack</span> s, <span class="type">int</span> e)</span>&#123;</span><br><span class="line">    StackNode *p = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(<span class="built_in">stack</span> s, <span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode *p = s-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTop</span><span class="params">(<span class="built_in">stack</span> s, <span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e = s-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实例">实例</h1><p><a href="https://www.luogu.com.cn/problem/P1449">P1449 后缀表达式 -洛谷 | 计算机科学教育新生态</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构-链表</title>
      
      <link href="/2025/01/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/01/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前情提要：<ahref="https://blog.4fgr.xyz/2025/01/06/数据结构-线性表/">数据结构-线性表| 4FGR の Blog</a></p></blockquote><h1 id="单链表">单链表</h1><p>​线性表的链式存储，其存储并非是一段连续的存储空间，为了能够访问链表中的元素，每个链表节点不仅存储了元素信息，还需要存放一个指向其后继的指针。（本文所有链表实现均有头节点）</p><p><strong>结构体定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><p><strong>基本操作的实现</strong></p><p><strong>初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">initList</span><span class="params">(LinkedList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>检查空表</strong></p><p>即检查头节点的后继是否为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LinkedList L)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素</span></span><br><span class="line">LNode* <span class="title function_">Find</span><span class="params">(LinkedList L, <span class="type">int</span> taget)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != taget)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;  <span class="comment">//找到返回指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><p>对于插入节点后继非空的情况下，插入方式如图</p><p><img src="\images\数据结构\单链表的插入.png" /></p><p>插入方法的代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在位置postion后插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(LinkedList L, LNode *position, <span class="type">int</span> e)</span>&#123;</span><br><span class="line">    LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = position-&gt;next; <span class="comment">//改变p的后继</span></span><br><span class="line">    position-&gt;next = p;<span class="comment">//改变position的后继</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>对于删除节点后继非空的情况下，删除方式如图</p><p><img src="\images\数据结构\单链表的删除.png" /></p><p>删除方法的代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素target</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(LinkedList L, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    LNode *q = p;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != target)&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到目标元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>销毁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteList</span><span class="params">(LinkedList &amp;L)</span>&#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    LNode *q = p;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建立单链表</strong></p><p><mark>头插法</mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateListFront</span><span class="params">(LinkedList &amp;L, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">        LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = data;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark>尾插法</mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateListRear</span><span class="params">(LinkedList &amp;L, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *r = L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">        LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = data;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双链表">双链表</h1><p>相比于单链表而言，双链表（双向链表）的定义中多了前驱pre，这对于任意一个非头节点而言，都可以直接访问其前驱节点。</p><p><strong>结构体定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkedList;</span><br></pre></td></tr></table></figure><p><strong>基本操作实现</strong></p><p>相比于单链表而言，差异在于对前驱和后继的处理，这里仅对<mark>插入</mark>和<mark>删除</mark>方法作出具体实现:</p><p><strong>插入</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在位置p后插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(DLinkedList l, DNode *position, <span class="type">int</span> e)</span>&#123;</span><br><span class="line">    DNode *p = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = position-&gt;next; <span class="comment">//注意改变指针域的顺序</span></span><br><span class="line">    p-&gt;prior = position;</span><br><span class="line">    position-&gt;next = p;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next)&#123;</span><br><span class="line">        p-&gt;next-&gt;prior = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素target</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(DLinkedList L, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    DNode *p = L;</span><br><span class="line">    DNode *q = p;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != target)&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next)&#123;</span><br><span class="line">            p-&gt;next-&gt;prior = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到目标元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环链表">循环链表</h1><p>单链表和双链表都有循环链表形式，对比之前链表的差异在于其最后节点的后继非空，而是指向头节点或第一个节点(无表头时)。特别地，对于双链表，还得注意头节点或第一个节点的前驱指向最后一个节点。</p><p>此时，对于类似<mark>查找</mark>、<mark>插入</mark>、<mark>删除</mark>等方法的实现，</p><p>应当遍历链表的条件不再为<b>p-&gt;next != NULL</b></p><p>而是 <b>p-&gt;next != L</b> (p从L-&gt;next开始时)</p><h1 id="扩展">扩展</h1><h2 id="链表求表长">链表求表长</h2><p>对于求出链表的表长，我们有两种方式，一种是通过简单的遍历得出，还有一种我们可以在链表的定义中加入表长信息，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>;</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LNode *head; <span class="comment">//存储链表头节点</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">//存储链表的表长</span></span><br><span class="line">&#125;LinkedList;</span><br></pre></td></tr></table></figure><p>当然，这会导致基本操作的实现要发生一定的变化，还需要记住基本操作中使表长改变的操作中，<strong>length</strong>需要被改变。</p><h2 id="其他">其他</h2><p>与上述添加length类似，我们还可以往LinkedList添加我们想要的成员，</p><p>例如，我们可以通过添加尾节点rear，使得对尾部节点的访问更便利。</p><p>因此，从实际需求出发，出于便利的需要，我们可以往链表中添加理想的成员。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构-线性表</title>
      
      <link href="/2025/01/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2025/01/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-线性表">数据结构-线性表</h1><blockquote><p>本文仅对线性表进行简单叙述，具体实现会专门出教程，并在具体的数据结构后面给出链接。</p></blockquote><p><strong>定义：<strong>线性表是具有</strong>相同</strong>数据类型的n个元素的<b>有限</b>序列</p><p><strong>基本操作：</strong>初始化、取值、查找、插入、删除、判空、销毁</p><h2 id="线性表的顺序表示-顺序表">线性表的顺序表示-顺序表</h2><p>我们可以这样定义顺序表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];  <span class="comment">//顺序表的元素(假设类型为int，本文元素均以int为例)</span></span><br><span class="line">    <span class="type">int</span> lenth; <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>当然，如果我们想要通过动态分配的顺序表，只需要让data成为一个指针，并且结构体中存在MaxSize描述当前最大容量即可。</p><p>特点：逻辑位置与其存储的物理顺序相同</p><p>优点：</p><ul><li>可随机访问（取值的时间复杂度为O(1)）</li><li>存储密度高</li></ul><p>缺点：</p><ul><li>插入和删除的时间花费较大</li></ul><h2 id="线性表的存储表示-链表">线性表的存储表示-链表</h2><blockquote><p>为了避免顺序表插入和删除的线性开销，我们可以允许表不连续存储，于是链表应运而生</p></blockquote><blockquote><p>我们常常使用头节点head置于链表最前端，其data域无任何东西，优点如下</p><p>1.第一个节点存放在头节点的指针域中，与其他节点一样，无需特殊处理</p><p>2.对空表和非空表的处理有了统一的标准(head-&gt;next是否为空)</p></blockquote><p><strong>单链表</strong></p><p>我们可以这样定义一个简单的单链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span> <span class="comment">//LNode为链表节点</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//链表节点对应的元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个链表节点的指针</span></span><br><span class="line">&#125;*LinkedList; </span><br></pre></td></tr></table></figure><p>我们使得*LNode， 即LinkedList来代表链表。</p><p>通过结构体指针next, 我们就可以遍历链表的所有元素。</p><p><strong>双向链表</strong></p><p>我们可以这样定义一个简单的双向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">pre</span>;</span> <span class="comment">//指向该节点的前驱</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span> //指向该节点的后继</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>循环链表</strong></p><p>单链表和双向链表都有其循环形式，结构体形式不需要做出任何改变，我们只需要它最后一个节点的后继是第一个节点即可，这样链表就形成了一个环。</p><h2 id="受限线性表-栈队列">受限线性表: 栈、队列</h2><p>它们都是一种线性表，只不过对于它们的功能都进行了限制，只能进行线性表的某些功能，这使得它们的特点和用途更加鲜明，功能更简洁。</p><p><b>栈</b></p><p>栈是一种只能在一端进行插入和删除的数据结构。就像我们整齐地放书本一样，我们只允许最后放的书可以被拿走或用新的书放在其上面。这种操作特性被称为“<strong>后进先出</strong>“</p><p>其中，栈的最后一个元素被称作栈顶元素。</p><p>栈实现的功能主要有两个：</p><p>pop: 弹出栈顶元素</p><p>push: 将元素压入栈顶</p><p>有时也会实现get top功能，即返回栈顶元素的值，而不弹出。</p><p><strong>队列</strong></p><p>队列是一种只能在一端进行删除，在另一端进行插入的数据结构。词如其名，正如我们排队一样，存在着”<strong>先进先出</strong>“的操作特性</p><p>队尾：进行插入的一端</p><p>队头(队首)：进行删除的一端</p><p>enQueue: 入队, 将元素放在队尾</p><p>deQueue: 出队, 删除队头元素</p><p><mark>栈和队列都是一种逻辑结构，都可以通过顺序存储和链式存储实现。</mark></p><h2 id="线性表的推广-数组">线性表的推广: 数组</h2><p>数组是由n个相同类型的数据元素构成的有限序列，每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。</p><p>数组是线性表的推广。一维数组可视为一个线性表，二位数组可视为其元素是定长数组的线性表，以此类推。</p><p>​数组一旦被定义，其维界就会确定，只能在该维界内存取元素和修改元素。</p><p>对于一维数组，其存储结构关系为:</p><center>LOC(a<sub>i</sub>) = LOC(a<sub>0</sub>) + i * L</center> <p>二维数组(i为高维，j为低维):</p><center>LOC(a<sub>ij</sub>) = LOC(a<sub>0</sub>) + i * row + j</center> <p>多维数组以此类推。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构绪论</title>
      
      <link href="/2025/01/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
      <url>/2025/01/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构绪论">数据结构绪论</h1><p>由于几天后数据结构要期末考试，最近几天会出数据结构相关的教程，以作复习。</p><blockquote><p>参考资料：</p><p>数据结构(C语言版) –严蔚敏，吴伟民</p><p>数据结构与算法分析 –Mark Allen Weiss</p><p>2025年数据结构考研复习指导 –王道论坛</p></blockquote><h2 id="数据结构的基本概念">数据结构的基本概念</h2><h3 id="基本术语">基本术语</h3><p><b>数据元素</b>：数据的基本单位，由若干数据项组成</p><p><b>数据对象</b>：具有相同性质的数据元素的集合</p><p><b>抽象数据类型：</b>一组操作的集合</p><p>​<strong>数据结构</strong>是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素之间的关系称为<strong>结构</strong>。数据结构包括三方面内容：<em>逻辑结构、存储结构和数据的运算</em></p><h3 id="数据结构三要素">数据结构三要素</h3><p><mark>1.数据的逻辑结构</mark></p><p>​逻辑结构是指数据元素之间的逻辑关系，与数据的存储无关，分为线性结构和非线性结构</p><p><img src="/images/数据结构/数据的逻辑结构.png" /></p><p><em>集合</em>：结构中的数据元素除“同属一个集合”外，别无其他关系。</p><p><em>线性结构</em>：结构中的数据存在一对一的关系</p><p><em>树形结构</em>：结构中的数据存在一对多的关系</p><p><em>图状结构</em>：结构中的数据存在多对多的关系</p><p>2.数据的存储结构</p><p>​ 存储结构是指数据结构在计算机中表示(又称映像)，也称物理结构。</p><ul><li>顺序存储：逻辑上相邻的元素存储在物理位置也相邻的存储单元中</li><li>链式存储：借助指示元素存储地址的指针来表示元素之间的逻辑关系</li><li>索引存储：建立附加的索引表</li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址</li></ul><h2 id="算法效率的度量">算法效率的度量</h2><p>一般情况下，算法中基本操作重复执行的次数是关于<strong>n</strong>的某个函数<strong>f(n)</strong>,算法的时间量度记作</p><center>T(n) = O(f(n))</center><blockquote><p>O的含义是T(n)的数量级，如果存在正常数c和n<sup>0</sup>，使得当n &gt;=n<sub>0</sub>时,T(n) &lt;= c f(n),则记为T(n) = O(f(n))</p></blockquote><p>我们通过这样的方式表示了算法执行时间的增长率，它主要是由O(f(n))决定的。</p><p>例如，若存在f(n) = 2<sup>n</sup> + n<sup>2</sup> , 则 O(f(n)) =2<sup>n</sup> 。显然，当n很大时，相比于2<sup>n</sup>,n<sup>2</sup>无足轻重了。</p><p>像这样，我们称O(f(n))为<strong>渐进时间复杂度</strong>，简称时间复杂度</p><p>同理，空间复杂度S(n) = O(g(n))</p><blockquote><p>使用g(n)是为了区别于f(n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>[题解]P1011 [NOIP1998 提高组] 车站</title>
      
      <link href="/2025/01/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8D%95%E9%A2%98%E8%A7%A3/%5B%E9%A2%98%E8%A7%A3%5DP1011-%5BNOIP1998-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E8%BD%A6%E7%AB%99/"/>
      <url>/2025/01/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8D%95%E9%A2%98%E8%A7%A3/%5B%E9%A2%98%E8%A7%A3%5DP1011-%5BNOIP1998-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E8%BD%A6%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="题目难点">题目难点</h2><p>对数学功底的考察，能否根据题目描述建立起数学公式,解出关键的未知数(第二次上下车的人数)</p><h2 id="题目">题目</h2><blockquote><p>洛谷链接： [P1011 <ahref="https://www.luogu.com.cn/problem/P1011">NOIP1998 提高组] 车站 -洛谷 | 计算机科学教育新生态</a></p><h1 id="noip1998-提高组-车站">[NOIP1998 提高组] 车站</h1><h2 id="题目描述">题目描述</h2><p>火车从始发站（称为第 <span class="math inline">\(1\)</span>站）开出，在始发站上车的人数为 <spanclass="math inline">\(a\)</span>，然后到达第 <spanclass="math inline">\(2\)</span> 站，在第 <spanclass="math inline">\(2\)</span>站有人上、下车，但上、下车的人数相同，因此在第 <spanclass="math inline">\(2\)</span> 站开出时（即在到达第 <spanclass="math inline">\(3\)</span> 站之前）车上的人数保持为 <spanclass="math inline">\(a\)</span> 人。从第 <spanclass="math inline">\(3\)</span> 站起（包括第 <spanclass="math inline">\(3\)</span>站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第<span class="math inline">\(n-1\)</span>站），都满足此规律。现给出的条件是：共有 <spanclass="math inline">\(n\)</span> 个车站，始发站上车的人数为 <spanclass="math inline">\(a\)</span>，最后一站下车的人数是 <spanclass="math inline">\(m\)</span>（全部下车）。试问 <spanclass="math inline">\(x\)</span> 站开出时车上的人数是多少？</p><h2 id="输入格式">输入格式</h2><p>输入只有一行四个整数，分别表示始发站上车人数 <spanclass="math inline">\(a\)</span>，车站数 <spanclass="math inline">\(n\)</span>，终点站下车人数 <spanclass="math inline">\(m\)</span> 和所求的站点编号 <spanclass="math inline">\(x\)</span>。</p><h2 id="输出格式">输出格式</h2><p>输出一行一个整数表示答案：从 <span class="math inline">\(x\)</span>站开出时车上的人数。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;5 7 32 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;13</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>对于全部的测试点，保证 <span class="math inline">\(1 \leq a \leq20\)</span>，<span class="math inline">\(1 \leq x \leq n \leq20\)</span>，<span class="math inline">\(1 \leq m \leq 2 \times10^4\)</span>。</p><p>NOIP1998 提高组 第一题</p></blockquote><h2 id="题解">题解</h2><p>对于这道题而言，我们发现存在两个斐波拉契数列，一个是下车，一个是上车</p><p>我们不妨设置第二站上下车的人数为b，</p><p>显然，getOn[1] = a, getOff[1] = 0, getOn[2] = getOff[2] = b.</p><p>对于第n站上车的人数而言(n&gt;2)：</p><center><b>getOn[n] = getOn[n-2]+getOn[n-1]</b></center><p>对于第n站下车的人数而言(n&gt;2):</p><center><b>getOff[n] = getOn[n-1]</b></center><p>问题是，我们并不知晓b为何值，b成为了解决这个车站问题的关键节点。</p><p>突破点是我们接受到的m,即第n站下车的总人数，实际上即车驶离第n-1站时车上的人数。</p><p>显然m 为所有 getOn[i] - getOff[i] 之和 (i&lt;=n-1)</p><p>通过表格</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th>…</th><th>k</th></tr></thead><tbody><tr><td style="text-align: center;">getOn</td><td style="text-align: center;">a</td><td style="text-align: center;">b</td><td style="text-align: center;">a+b</td><td style="text-align: center;">a+2b</td><td>…</td><td>getOn[k]</td></tr><tr><td style="text-align: center;">getOff</td><td style="text-align: center;">0</td><td style="text-align: center;">b</td><td style="text-align: center;">b</td><td style="text-align: center;">a+b</td><td>…</td><td>getOn[k-1]</td></tr></tbody></table><p>我们不妨发现，getOff[i]与getOn[i-1]抵消，</p><p>于是乎，在已知b的值的情况下，我们得到：</p><center><b>m = a-b + getOn[n-1]</b></center><p>我们已经知道a和m,为了得到b,我们还需要getOn[n-1],</p><p>在我们不知道b时，我们可以把getOn[n-1]分解成</p><center><b>getOn[n-1] = fibcal(a,0,n-1) + fibcal(0,1,n-1) * b</b></center><p>其中, fibcal为计算斐波拉契数的函数</p><p>将此式子带入上式，我们可以求出b的值,</p><!--对于n==2时的情况，显然b = m-a;--><p>同理，之后对于所求的车开出第x站时的车上人数res为:</p><center><b>res = a-b+fibcal(a,b,x)</b></center><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">fibcal</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m,x;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> part1 = <span class="built_in">fibcal</span>(<span class="number">0</span>,<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> part2 = <span class="built_in">fibcal</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> b = (n==<span class="number">2</span>? m-a :(m-a-part2)/(part1<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">3</span>)&#123;</span><br><span class="line">        res = a-b+<span class="built_in">fibcal</span>(a,b,x);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">       cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">fibcal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="type">long</span> res[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    res[<span class="number">0</span>] = a;</span><br><span class="line">    res[<span class="number">1</span>] = b;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-2</span>; i++)&#123;</span><br><span class="line">        res[(i<span class="number">+2</span>)%<span class="number">3</span>] = res[i%<span class="number">3</span>] + res[(i<span class="number">+1</span>)%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">    i = (i<span class="number">+2</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> res[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斐波拉契 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>梦境巡查-第三十六次CCF认证(CSP)第二道题个人题解</title>
      
      <link href="/2024/12/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8D%95%E9%A2%98%E8%A7%A3/%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E6%AC%A1CCF%E8%AE%A4%E8%AF%81(CSP)%E7%AC%AC%E4%BA%8C%E9%81%93%E9%A2%98%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/12/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%8D%95%E9%A2%98%E8%A7%A3/%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E6%AC%A1CCF%E8%AE%A4%E8%AF%81(CSP)%E7%AC%AC%E4%BA%8C%E9%81%93%E9%A2%98%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<ahref="https://sim.csp.thusaac.com/contest/36/problem/1">TUOJ</a>（需有账号）</p><h2 id="题目背景">题目背景</h2><p>传说每当月光遍布西西艾弗岛，总有一道身影默默守护着居民们的美梦。</p><h2 id="题目描述">题目描述</h2><p>梦境中的西西艾弗岛由<em>n</em>+1个区域组成。梦境巡查员顿顿每天都会从梦之源（0 号区域）出发，顺次巡查1,2,⋯,n 号区域，最后从<em>n</em> 号区域返回梦之源。</p><p>在梦境梭需要消耗美梦能量：</p><ul><li>从梦之源出发时，顿顿会携带若干初始能量；</li><li>从第 <em>i</em>号区域前往下一区域（0≤<em>i</em>≤<em>n</em>）需要消耗 a<sub>i</sub>单位能量，因此从第 <em>i</em>号区域出发时，顿顿剩余的美梦能量需要<strong>大于或等于</strong>a<sub>i</sub>单位；</li><li>顺利到达第 i*号区域（1≤<em>i</em>≤<em>n</em>）后，顿顿可以从当地居民的美梦中汲取b<sub>i</sub> 单位能量作为补给。</li></ul><p>假设顿顿初始携带 <em>w</em> 单位美梦能量，那么首先需要保证w*≥<em>a</em>0，这样顿顿便可消耗<em>a</em>0 能量穿梭到 1号区域、进而获得 <em>b</em><sub>1</sub> 单位能量补给。巡查 1号区域后，顿顿剩余能量为w−a<sub>0</sub>+b<sub>1</sub>，如果该数值大于或等于a*1，顿顿便可继续前往 2 号区域。依此类推，直至最后消耗<em>a<sub>n</sub></em> 单位能量从 <em>n</em>号区域返回梦之源，便算是顺利完成整个巡查。西西艾弗岛，又迎来安宁的一夜，可喜可贺！</p><p><imgsrc="https://sim.csp.thusaac.com/staticdata/182.3FmGAD6RWP1oNsMo.pub/P03t1e8k3AyEZuvy.demo.png/demo.png"alt="img" /></p><p>作为一个成熟的梦境巡查员，顿顿已经知晓初始需要携带多少能量可以保证顺利完成巡查。但在一些意外状况下，比如学生们受期末季的困扰而无法安眠，顿顿可能在某些区域无法采集足够的美梦能量。此时，便需要增加初始携带量以备万全。</p><p>具体来说，考虑一个简单的情况：在 1 到 <em>n</em>号区域中，有且仅有一个区域发生意外，顿顿无法从该区域获得能量补给。如果第 <em>i</em> 号区域(1≤<em>i</em>≤<em>n</em>）发生意外（即b<sub>i</sub> 变为0），则此时为顺利完成巡查，顿顿从梦之源出发所携带的最少初始能量记作<em>w</em>(<em>i</em>)。</p><p>试帮助顿顿计算w*(1),<em>w</em>(2),⋯,<em>w</em>(<em>n</em>) 的值。</p></blockquote><p>为了简便的需要,我们设置所有数组长度为n+1，数组下标直接与节点对应。</p><p>结果为</p><p>w[i] = dp1[i] + max(0,dp2[i] - remain[i]);</p><p>当然 w[i] = max(dp1[i], dp1[i] + dp2[i] - remain[i])也是可以的(下面同理)</p><p>我的设置如下:</p><p>dp1[i]是到达第i个节点所需要的最小能量</p><p>dp2[i]是从第i个节点开始顺利完成任务所需要的最小能量</p><p>remain[i]是到达第i个节点前所剩余的能量(当到达方式最优时)</p><p>其中dp1的状态转移方程为</p><center>dp1[i+1] = dp1[i] + max(0, a[i] - remain[i+1])</center><p>dp2的状态转移方程为</p><center>dp2[i] = a[i] + max(0, dp2[i+1] - b[i+1]) </center><p>更新remain:</p><p>remain[i+1] = max(0,remain[i+1] - a[i])</p><p>(用if语句也行)</p><p>我的思路是，既然我们要求当第i节点故障时(即无法获取b[i]能量)，顺利完成任务所需要的最少能量，显然是到达这个节点所需要的最少能量，加上从这个节点到最终节点最后回到起始节点所需要的最少能量。由于到达这个节点时，补给所获取的能量还有剩余，所以可以补充后一段的路程，当然这是不可能直接相减的（后一段最少能量不可能为负数），因此一共是max(0,dp2[i] - remain[i]), 总体就是dp1[i] + max(0, dp2[i] - remain[i])。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); <span class="comment">//取消c++与stdio的同步，使得cin和cout变快</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//若下标为i,a[i]表示从第i节点到第i+1节点所需的能量</span></span><br><span class="line">    <span class="comment">//a[n]表示从第n节点回到第0节点所需的能量</span></span><br><span class="line">    <span class="type">int</span> a[n<span class="number">+1</span>]; </span><br><span class="line">    <span class="comment">//b[i]表示第i节点可补给的能量，b[0]无用</span></span><br><span class="line">    <span class="type">int</span> b[n<span class="number">+1</span>];</span><br><span class="line">    <span class="type">int</span> dp1[n<span class="number">+1</span>];</span><br><span class="line">    <span class="type">int</span> dp2[n<span class="number">+1</span>];</span><br><span class="line">    <span class="type">int</span> remain[n<span class="number">+1</span>];</span><br><span class="line">    <span class="type">int</span> w[n<span class="number">+1</span>]; <span class="comment">//存储结果</span></span><br><span class="line">    remain[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//显然一开始补给点的能量为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    dp1[<span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        remain[i<span class="number">+1</span>] = remain[i]+b[i];</span><br><span class="line">        dp1[i<span class="number">+1</span>] = dp1[i] + <span class="built_in">max</span>(<span class="number">0</span>, a[i] - remain[i<span class="number">+1</span>]); <span class="comment">//获取dp1</span></span><br><span class="line">remain[i<span class="number">+1</span>] = <span class="built_in">max</span>(<span class="number">0</span>,remain[i<span class="number">+1</span>] - a[i]); <span class="comment">//更新remain</span></span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; b[n]; <span class="comment">//防止dp1、remain数组溢出，单独放置</span></span><br><span class="line">    dp2[n] = a[n]; <span class="comment">//显然从第n节点回到第1节点所需能量为a[n]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        dp2[i] = a[i] + <span class="built_in">max</span>(<span class="number">0</span>, dp2[i<span class="number">+1</span>] - b[i<span class="number">+1</span>]) ;  <span class="comment">//获取dp2</span></span><br><span class="line">        w[i] = <span class="built_in">max</span>(dp1[i], dp1[i] + dp2[i] - remain[i]); <span class="comment">//得到w[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    w[n] = <span class="built_in">max</span>(dp1[n], dp1[n]+ dp2[n] - remain[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cout &lt;&lt; w[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">//输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>数据结构-散列表(hash table)</title>
      
      <link href="/2024/12/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8(hash-table)/"/>
      <url>/2024/12/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8(hash-table)/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-散列表hash-table">数据结构-散列表(hash table)</h1><blockquote><p>参考资料：数据结构与算法分析 –Mark Allen Weiss</p></blockquote><h2 id="一基本介绍">一、基本介绍</h2><p><strong>散列(hashing)</strong>：一种以常数平均时间执行插入、删除和查找的技术，但对元素间进行排序的操作不被支持，例如寻找最大值和最小值。</p><p><strong>散列表（hash table）</strong>:一个含有关键字的具有固定大小的数组，通过关键字查找对应值，只需要O(1)的时间复杂度。</p><p><strong>散列函数</strong>：将每个关键字映射到从0到size-1这个范围中的某个数，并且放到适当的单元。这个映射就叫做散列函数。</p><h2 id="二散列函数">二、散列函数</h2><p><strong>关键字为整数的设置方法:</strong></p><p>如果输入的关键字是整数，则一般合理的方法就是直接返回 <mark>关键字%表长</mark>,最好保证表长为<mark>素数</mark>（质数），以避免某些特殊情况，例如表长为10，而关键字均以0为个位的情况。</p><p><strong>关键字为字符串的设置方法</strong>:</p><ul><li>通常，关键字是字符串，在这种情形下，散列函数需要仔细选择。</li></ul><p>用ASCII码直接相加并取余并不合适,表长很大，就不能均匀地很好地分配关键字。</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">int</span> len)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">0</span>; <span class="comment">//显然，hash值不为负</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( *key != <span class="string">&#x27;\0&#x27;</span>) &#123;hash += *key; key++;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash % len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而另一个散列如代码所示, 当key长度为3时：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *key, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (key[<span class="number">0</span>] + <span class="number">27</span> * key[<span class="number">1</span>]+ <span class="number">27</span>*<span class="number">27</span> key[<span class="number">2</span>]) % len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>27表示英文字母加一个空格的个数，如果key是随机的，那么就会得到一个合理分配，但英文不是随机的,这导致我们会造成很大的空间浪费，特别是表长足够大时。</p><ul><li><p>下面列出一个较好的方法,它计算：</p><p><math xmlns='http://www.w3.org/1998/Math/MathML'> <munderover> <mrow><mo> ∑ <!-- n-ary summation --> </mo> </mrow> <mrow> <mi> i </mi> <mo> =</mo> <mn> 0 </mn> </mrow> <mrow> <mi> k </mi> <mi> e </mi> <mi> y </mi><mi> s </mi> <mi> i </mi> <mi> z </mi> <mi> e </mi> <mo> - </mo> <mn> 1</mn> </mrow> </munderover> <mi> k </mi> <mi> e </mi> <mi> y </mi><mrow> <mo> [ </mo> <mi> k </mi> <mi> e </mi> <mi> y </mi> <mi> s </mi><mi> i </mi> <mi> z </mi> <mi> e </mi> <mo> - </mo> <mi> i </mi> <mo> -</mo> <mn> 1 </mn> <mo> ] </mo> </mrow> <mo> ×<!-- multiplication sign --> </mo> <msup> <mrow> <mn> 32 </mn> </mrow><mrow> <mi> i </mi> </mrow> </msup> </math></p><p>程序根据Horner法则计算一个(32的)多项式函数,之所以不用27，是因为32可以通过“&lt;&lt;“右移五位获得</p><blockquote><p>Horner法则， 例如 res = n<sub>1</sub> + 27n<sub>2</sub> +27<sup>2</sup>n<sub>3</sub>可转换为 res = ( (k<sub>3</sub>)*27+k<sub>2</sub>)* 27 + n<sub>1</sub></p></blockquote><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">0</span>; <span class="comment">//显然hash值为0,数组下标是为正的</span></span><br><span class="line">    <span class="keyword">while</span>(*key != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    hash = (hash&lt;&lt;<span class="number">5</span>) + *key;</span><br><span class="line">        key++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % len;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>剩下解决的就是当插入元素对应的散列值(hash)已经存在，如何消除这个冲突的问题，我们讨论最简单的两种:</p><center> <b>分离链接法</b> 和 <b>开放定址法 </b></center><h2 id="三-分离链接法">三、 分离链接法</h2><p>​将散列到同一个值的所有元素保留在一个表中。为方便起见，这些表都有表头，如果空间很紧，更可取的方法是避免使用这些表头。（表长不用素数是为了简单起见，这里表长为10）</p><p><img src="https://ooo.0x0.ooo/2024/11/28/OLMzAa.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    E data; <span class="comment">//元素类型为E</span></span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>,*<span class="title">List</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    List *lists;</span><br><span class="line">&#125;*HashTable;</span><br></pre></td></tr></table></figure><p>为简洁需要，以下代码并未有健壮性检查，自己实现时记得加上()。</p><p><strong>初始化</strong>：它用到与栈的数组实现中相同的想法。设置表的大小为一个素数，指定List的一个指针数组,如果要有表头，就必须给每个表分配一个表头并且设置next为NULL；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HashTable <span class="title function_">InitalizeTable</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">HashTable H;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HashTbl));</span><br><span class="line">    H-&gt;size = size;</span><br><span class="line">    <span class="comment">/* 为确保size是质数，可实现NextPrime函数</span></span><br><span class="line"><span class="comment">    H-&gt;size = NextPrime(size);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    H-&gt;lists = (List *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List)*H-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;H-&gt;size; i++)&#123;</span><br><span class="line">        H-&gt;lists[i] = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        H-&gt;lists[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong>：我们使用散列元素来确定究竟考察哪个表，此时通常采用遍历的方式,返回被查找项所在位置</p><p>如果<em>data</em>类型是<em>字符串</em>，则比较和赋值相应地用<em>strcmp</em>和<em>strcpy</em>进行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode* <span class="title function_">Find</span><span class="params">(E key, HashTable H)</span>&#123;  <span class="comment">//返回关键字对应的指针</span></span><br><span class="line">    ListNode *p,*l;</span><br><span class="line">    l = (List)H-&gt;lists[Hash(key, H-&gt;size)];  <span class="comment">//找到对应的表</span></span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != key)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong>：查找元素是否已经处在合适的位置(如果要插入重复元，那么通常要留出一个额外的域，这个域党重复出现时自增1)，根据容易度，新元素或者插入表的前端，或者后端。有时将新元素插入到表的前端不仅方便，而且还因为新进插入的元素最有可能优先被访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(E key, HashTable H)</span>&#123;</span><br><span class="line">ListNode *pos,*p;</span><br><span class="line">    List l;</span><br><span class="line">    </span><br><span class="line">    pos = Find(key, H);</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="literal">NULL</span>)&#123;  <span class="comment">//key不在散列中,可以插入</span></span><br><span class="line">        p = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        l = H-&gt;lists[Hash(key, H-&gt;size)];</span><br><span class="line">        p-&gt;next = l-&gt;next;  <span class="comment">//此处采用前插法</span></span><br><span class="line">        p-&gt;data = key;</span><br><span class="line">        l-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四开放定址法">四、开放定址法</h2><p>​分离链接法的缺点是需要指针，由于给新单元分配地址需要时间，因此这就导致算法的速度多少有些减慢。<em>开放定址散列法</em>（openaddressing hashing）是另外一种用链表解决冲突的方法,如果有冲突发生，就尝试找到另外空的单元。更一般地，单元 h<sub>0</sub>(X),h<sub>1</sub>((X),···,相继试选，其中<mark>h<sub>i</sub>((X)=(Hash(X)+F(i)) %size</mark>,且<mark>F(0) =0</mark>。函数F是冲突解决方法。因为所有的数据都要置入表内，所以该算法所需要的表要比分离链接法的表要大，一般说来，装填因子应该低于0.5。现在我们就来考察三个通常的冲突解决方法。</p><h3 id="1线性探测法">1.线性探测法</h3><p>在该方法中，函数F为i的<strong>线性函数</strong>，常用F(i)=i。这相当于逐个探测每个单元(必要时可以绕回)以查找出一个空单元。只要表足够大，总能找到一个自由单元，但较为消耗时间。另外，即便表相对较空，这样占据的单元也会开始形成一些区块，其结果称为<strong>一次聚集</strong>（primaryclustering）。于是，散列到区块中的任何关键字都需要多次试选，才能被添加到相应的区块中。</p><h3 id="2平方探测法">2.平方探测法</h3><p>​平方探测法是一种消除线性探测中一次聚集问题的冲突解决方法，是冲突函数为<strong>二次函数</strong>的方法，常用F(i)=i<sup>2</sup>。例如，对于<em>49,89,18,58</em>而言,当要放89时，其位置与49发生冲突，其下一个位置为下一个单元，而当要放58时，其后相邻的单元经探测得知发生了另外的冲突。其下一个位置在距离位置8为<em>2<sup>2</sup>=4</em> 远处，也就是位置2处。</p><p>​对于线性探测，让元素填充满散列表并不好，而对于本方法而言情况甚至更糟。如果使用平方探测，且表的大小是素数，那么当表至少有一半是空的时候，总能够插入一个新的元素。</p><p>​在开放定址散列表中，删除操作需要懒惰删除，虽然这种情况并不存在真正意义上的懒惰。</p><p>​ 实现开放定址散列:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> Index;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KindOfEntry</span>&#123;</span>Legitimate, Empty, Deleted&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span>&#123;</span></span><br><span class="line">    E data;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">KindOfEntry</span> <span class="title">info</span>;</span></span><br><span class="line">&#125;Cell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Cell *cells;</span><br><span class="line">&#125;*HashTable;</span><br></pre></td></tr></table></figure><p><strong>初始化</strong>:由分配空间和其后每个单元的<em>info</em>域设置成<em>Empty</em>组成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HashTable <span class="title function_">InitializeTable</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    HashTable H;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HashTbl));</span><br><span class="line">    H-&gt;size = size;</span><br><span class="line">    H-&gt;cells = (Cell *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cell)*H-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;H-&gt;size; i++)&#123;</span><br><span class="line">        H-&gt;cells[i].info = Empty;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong>：找到返回key的位置，否则返回最后的单元，以方便插入。查找是否失败，通过枚举值便知晓。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Index <span class="title function_">Find</span><span class="params">(E key, HashTable H)</span>&#123;</span><br><span class="line">    Index CurrentPos;</span><br><span class="line">    <span class="type">int</span> CollisionNum;</span><br><span class="line"></span><br><span class="line">    CollisionNum = <span class="number">0</span>;</span><br><span class="line">    CurrentPos = Hash(key, H-&gt;size);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;cells[CurrentPos].info != Empty &amp;&amp; H-&gt;cells[CurrentPos].data != key)&#123;</span><br><span class="line">        CurrentPos += <span class="number">2</span>*++CollisionNum - <span class="number">1</span>;  <span class="comment">//平方探测法</span></span><br><span class="line">        <span class="keyword">if</span>(CurrentPos &gt;= H-&gt;size)&#123;</span><br><span class="line">            CurrentPos -= H-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CurrentPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong>:将插入的元素放在Find所指出的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(E key, HashTable H)</span>&#123;</span><br><span class="line">    Index Pos;</span><br><span class="line">    Pos = Find(key, H);</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;cells[Pos].info != Legitimate)&#123;</span><br><span class="line">        H-&gt;cells[Pos].info = Legitimate;</span><br><span class="line">        H-&gt;cells[Pos].data = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然平方探测法排除了一次聚集，但是散列到同一位置上的那些元素将探测相同的备选单元，这叫做<strong>二次聚集</strong>(secondaryclustering)。这是理论上的一个小缺憾，模拟结果指出，它一般要引起另外的少于一半的探测。下面的技术将会排除这个缺憾。</p><h3 id="3双散列">3.双散列</h3><p>​ 我们考察的最后一个冲突解决方法叫做双散列(doublehashing)。对于双散列，一种流行的选择是F(i)=i*hash<sub>2</sub>((X)。显然，hash<sub>2</sub>选择得不好将会是灾难性的，函数一定不要算得0值。另外，保证所有单元都能被探测到也是很重要的，诸如<em>hash<sub>2</sub>((X)=R-(X % R)</em>这样的函数将起到良好的作用。其中R为小于size的素数。如果表的大小不是素数，那么备选单元就有可能提前用完。但由于平方探测不需要使用第二个散列函数，从而在实践中可能更简单并且更快。</p><h2 id="五再散列">五、再散列</h2><p>​对于使用平方探测的开发定址散列法，如果表中元素太满，那么操作的运行时间将开始消耗过长，且插入操作可能失败。此时，一种解决方法是建立另外一个大约两倍大的表（而且使用一个相关的新散列函数），扫描整个原始散列表，计算每个元素的新散列值并将其插入到新表中。整个操作就叫做<strong>再散列</strong>(rehashing)。</p><p>​ 显然这是一种较为昂贵的操作，运行时间为O(n),但由于不是经常发生，因此实际效果还行。特别是，在最后的再散列之前必然已经存在N/2次的<em>Insert</em>,当然添加到每个插入上的花费基本上是一个常数开销。</p><p>​ 推荐再散列的一种实现方法：途中(middle-of-the-road)策略</p><p>​当表到达某一个装填因子时进行再散列。由于随着装填因子的增加，表的性能的确有下降，因此，以好的截止手段实现，可能是最好的策略。</p><p>​再散列使我们再不用担心表的大小，这很重要，因为在复杂的程序中散列表不能够做到任意大。</p><p>对开放定址散列表的再散列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HashTable <span class="title function_">Rehash</span><span class="params">( HashTable H)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,OldSize;</span><br><span class="line">    Cell *OldCells;</span><br><span class="line"></span><br><span class="line">    OldCells = H-&gt;cells;</span><br><span class="line">    OldSize = H-&gt;size;</span><br><span class="line">    </span><br><span class="line">    H = InitializeTable(<span class="number">2</span>* OldSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; OldSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(OldCells[i].info == Legitimate)</span><br><span class="line">            Insert( OldCells[i].data, H);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(OldCells);</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>感谢观看！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 散列 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>各编程语言的运算符优先级</title>
      
      <link href="/2024/11/24/2024-11-24-%E5%90%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2024/11/24/2024-11-24-%E5%90%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="五大编程语言的运算符优先级">五大编程语言的运算符优先级</h1><blockquote><p>图片来自网络, 本文仅供分享、学习目的</p></blockquote><h2 id="c语言">C语言</h2><p><img src="\images\2024-11-24\OIP-C.jpg" alt="OIP-C" /></p><h2 id="c">C++</h2><p><img src="\images\2024-11-24\OIP-CPP.png" alt="OIP-CPP" /></p><h2 id="java">Java</h2><p><img src="\images\2024-11-24\OIP-Java.jpg" alt="OIP-Java" /></p><h2 id="python">Python</h2><p>下为Python3的各符号优先级顺序，优先级从高到低</p><p><img src="\images\2024-11-24\OIP-Python.png" alt="OIP-Python" /></p><h2 id="go">Go</h2><p>Go的各运算符优先级如下，优先级==从低到高==</p><p><img src="\images\2024-11-24\OIP-Go.png" alt="OIP-Go" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      
        <title>记录我的第一个博客</title>
      
      <link href="/2024/11/19/hello-world/"/>
      <url>/2024/11/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>·很高兴创建了我的第一个博客，之后我会努力学习，并分享我的收获和经验</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>